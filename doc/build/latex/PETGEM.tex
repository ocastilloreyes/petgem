%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{PETGEM Documentation}
\date{Jun 03, 2021}
\release{0.8}
\author{Octavio Castillo-Reyes}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{What is PETGEM?}
\label{\detokenize{WhatIs:what-is-petgem}}\label{\detokenize{WhatIs:id1}}\label{\detokenize{WhatIs::doc}}
Electromagnetic methods (EM) are an established tool in geophysics, with
application in many areas such as hydrocarbon and mineral exploration,
reservoir monitoring, CO$_{\text{2}}$ storage characterization, geothermal reservoir
imaging and many others. In particular, the marine Controlled-Source
Electromagnetic method (CSEM) and the 3D magnetotelluric (MT) method have become
important techniques for reducing ambiguities in data interpretation
in exploration geophysics. In order to be
able to predict the EM signature of a given geological structure, modelling
tools provide us with synthetic results which we can then compare to real data.
In particular, if the geology is structurally complex, one might need to use
methods able to cope with such complexity in a natural way by means of, e.g.,
an unstructured mesh representing its geometry. Among the modelling methods
for EM based upon 3D unstructured meshes, the High-order Nédélec Finite Elements (FE),
a type of Edge Finite Elements, offer a good trade-off between accuracy and number
of degrees of freedom, i.e. size of the problem.

In the multi-core and many-core era, parallelization is a crucial issue.
Nédélec FE offer good scalability potential. Its low DOF number make them potentially fast, which is
crucial in the future goal of solving inverse problems which might
involve over 100,000 realizations (e.g. within a inversion routine). However, the state of the art shows a
relative scarcity of robust high-order edge-based codes to simulate these problems.

On top of that, \sphinxstylestrong{Parallel Edge-based Tool for Geophysical Electromagnetic
Modelling} (PETGEM) is a \sphinxhref{https://www.python.org/}{Python} tool
for the scalable solution of the EM modeling on tetrahedral meshes, as these are the
easiest to scale-up to very large domains or arbitrary shape. It supports
distributed-memory paralelism through \sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py}
package.

As a result, PETGEM tool allow users to specify high-order edge-based
variational forms of H(curl) for the simulation of electromagnetic fields
in realistic 3D active-source (e.g. CSEM) and 3D passive-source (e.g. MT) surveys
with accuracy, reliability and efficiency.

PETGEM is developed as open-source under
\sphinxcode{\sphinxupquote{BSD-3}} license at Computer
Applications in Science \& Engineering
(\sphinxhref{http://www.bsc.es/computer-applications}{CASE})
of the Barcelona Supercomputing Center (\sphinxhref{http://www.bsc.es/}{BSC}).
Requests and contributions are welcome.


\chapter{Features}
\label{\detokenize{Features:features}}\label{\detokenize{Features:id1}}\label{\detokenize{Features::doc}}
PETGEM use a code structure for the high-order Nédélec FE algorithm that emphasizes
good parallel scalability, which is crucial in the multi-core era.
Furthermore, it’s modularity should simplify the process of reaching the
best possible performance in terms of percentage of the peak amount of
floating point operations provided by the architecture.


\section{Software stack}
\label{\detokenize{Features:software-stack}}\label{\detokenize{Features:id2}}
An outline of the primary groups of modules in PETGEM design is
given in {\hyperref[\detokenize{Features:figure-3-1}]{\sphinxcrossref{Figure 3.1}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{softwareStack}.jpg}
\caption{Figure 3.1. Upper view of PETGEM software stack.}\label{\detokenize{Features:id13}}\label{\detokenize{Features:figure-3-1}}\end{figure}

A more detailed explanation is the following:
\begin{itemize}
\item {} 
Modular and extensible EFEM kernel: The kernel is extensible in any direction. Therefore, the possibility of adding new features such as new boundary conditions, numerical algorithms, analysis modules, among others.

\item {} 
Independent of problem formulation, numerical solution, and data storage: The kernel provides the independent abstractions for modeling, numerical methods, data storage and analysis.

\item {} 
Parallel processing support: Based on distributed-memory parallelism (\sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py}) and static load balancing.  Further, GPUs architectures are supported.

\item {} 
Confidence and performance monitoring: Based on an simple and automatic profiling module.

\item {} 
Efficient solvers \& preconditioners: Direct as well as iterative solvers and preconditioners are supported through \sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py} package. As result, \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} and \sphinxhref{http://mumps.enseeiht.fr/}{MUMPs} libraries are supported.

\item {} 
Interface to mesh generator: Simple and light library to export nodal finite element meshes to edge elements data structures. Current version support \sphinxhref{http://gmsh.info/}{Gmsh} meshes.

\item {} 
Edge FEM library: High-order Edge-based discretisations, vector basis functions, their geometry description, and generalized integration rules provides a generic support for implementing high-order edge-based solution algorithms.

\item {} 
Linear systems library: Support to Compressed Row Storage (CSR) format for sparse matrices and their easy and efficient parallel assembly on distributed-memory platforms.

\item {} 
CSEM/MT module: Ad-hoc design to meet specific requirements for the solution 3D CSEM/MT surveys, namely, conductivity model, physical parameters, transmitter and receiver lists.

\item {} 
Pre-processing suite: Set of \sphinxhref{https://www.python.org/}{Python} functions for pre-processing phase within PETGEM.

\item {} 
Documentation: Available in HTML and PDF format through \sphinxhref{http://www.sphinx-doc.org}{Sphinx} and \sphinxhref{https://www.latex-project.org/}{LaTeX} (textlive).

\end{itemize}


\section{Programming language}
\label{\detokenize{Features:programming-language}}\label{\detokenize{Features:id3}}
PETGEM is based on \sphinxhref{https://www.python.org/}{Python} language
programming because:
\begin{itemize}
\item {} 
It is open source and functional on a wide number of platforms, including HPC environments.

\item {} 
It uses a high level and very expressive language.

\item {} 
It is based on a sophisticated array manipulation in a Fortran-like manner.

\item {} 
It uses a good body of bindings to common tools needed in scientific computing: plotting, numerical libraries, debugging and testing.

\end{itemize}

The code structure is modular, simple and flexible which allows exploiting
not just our own modules but also third party libraries. Therefore,
the software stack includes interfaces to external suites of data structures
and libraries that contain most of the necessary building blocks needed
for programming large scale numerical applications, e.g. sparse matrices,
vectors, iterative and direct solvers. As a result,
the code is compact and eliminates the need to write such libraries
and thus speeds up development time by orders of magnitude %
\begin{footnote}[1]\sphinxAtStartFootnote
Bangerth, W., Burstedde, C., Heister, T., and Kronbichler, M. (2011). Algorithms and data structures for massively parallel generic adaptive finite element codes. ACM Transactions on Mathematical Software (TOMS), 38(2):14.
%
\end{footnote}, %
\begin{footnote}[2]\sphinxAtStartFootnote
Heister, T., Kronbichler, M., and Bangerth, W. (2010). Massively parallel finite element programming. Recent Advances in the Message Passing Interface, pages 122\textendash{}131.
%
\end{footnote},
%
\begin{footnote}[3]\sphinxAtStartFootnote
Key, K. and Ovall, J. (2011). A parallel goal-oriented adaptive finite element method for 2.5-d electromagnetic modelling. Geophysical Journal International, 186(1):137\textendash{} 154.
%
\end{footnote}, %
\begin{footnote}[4]\sphinxAtStartFootnote
Osseyran, A. and Giles, M. (2015). Industrial Applications of High-Performance Computing: Best Global Practices. Chapman \& Hall/CRC Computational Science. CRC Press, first edition.
%
\end{footnote}.

In order to meet the high computational cost of the modeling, PETGEM supports
distributed-memory parallelism through \sphinxhref{https://bitbucket.org/petsc/petsc4py}{Petsc4py} package.


\section{Target architecture}
\label{\detokenize{Features:target-architecture}}\label{\detokenize{Features:id8}}
The HPC goal of the PETGEM involves using cutting-edge architectures.
To that goal, the code is implemented in current state-of-the-art
platforms such as Intel Xeon Platinum processors from the Skylake generation,
Intel Haswell and Intel Xeon Phi processors, which offer
high-performance, flexibility, and power efficiency. Nevertheless,
PETGEM support older architectures such as SandyBridge, for the sake
of usability and to be able to compare performance.


\chapter{CSEM/MT forward modeling \& High-order edge finite element method}
\label{\detokenize{Mathbackground:csem-mt-forward-modeling-high-order-edge-finite-element-method}}\label{\detokenize{Mathbackground:math-background}}\label{\detokenize{Mathbackground::doc}}
The last decade has been a period of rapid growth for electromagnetic
methods (EM) in geophysics, mostly because of their industrial adoption.
In particular, the 3D marine controlled-source electromagnetic (3D CSEM) method
and 3D magnetotelluric (3D MT) method have become important techniques for
reducing ambiguities in data interpretation in exploration geophysics.
In order to be able to predict the EM signature of a given geological structure,
modeling tools provide us with synthetic results which we can then compare to
measured data. In particular, if the geology is structurally complex, one might
need to use methods able to cope with such complexity in a natural way by means of, e.g., an
unstructured mesh representing its geometry. Among the modeling methods
for EM based upon 3D unstructured meshes, the high-order Nédélec Edge Finite Element
Method (HEFEM) offers a good trade-off between accuracy and number of degrees
of freedom, e.g. size of the problem. Furthermore, its divergence-free basis
is very well suited for solving Maxwell’s equation. On top of that, we choose
to support tetrahedral meshes, as these are the easiest to use for very large
domains or complex geometries.

We refer to the following papers for a complete discussion of
marine/land 3-D CSEM/MT modelling and its problem statement within PETGEM:
\begin{itemize}
\item {} 
Castillo-Reyes, O., Queralt, P., Marcuello, A., Ledo, J. (2021). \sphinxhref{https://doi.org/10.1109/TGRS.2021.3069042}{Land CSEM Simulations and Experimental Test Using Metallic Casing in a Geothermal Exploration Context: Vall{}`es Basin (NE Spain) Case Study}. IEEE Transactions on Geoscience and Remote Sensing.

\item {} 
Castillo-Reyes, O., de la Puente, J., García-Castillo, L. E., Cela, J.M. (2019). \sphinxhref{https://doi.org/10.1093/gji/ggz285}{Parallel 3-D marine controlled-source electromagnetic modelling using high-order tetrahedral Nédélec elements}. Geophysical Journal International, Volume 219, Issue 1, October 2019, Pages 39\textendash{}65.

\item {} 
Castillo-Reyes, O., de la Puente, Cela, J. M. \sphinxhref{https://doi.org/10.1016/j.cageo.2018.07.005}{PETGEM: A parallel code for 3D CSEM forward modeling using edge finite elements}. Computers \& Geosciences, vol 119: 123-136. ISSN 0098-3004. Elsevier.

\end{itemize}


\chapter{Installation}
\label{\detokenize{Installation:installation}}\label{\detokenize{Installation:id1}}\label{\detokenize{Installation::doc}}
This section describe the requirements and installation steps for PETGEM.


\section{Requirements}
\label{\detokenize{Installation:requirements}}\label{\detokenize{Installation:requeriments}}
PETGEM is known to run on various flavors of Linux clusters. Its requirements are:
\begin{itemize}
\item {} 
\sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} (builded version for \sphinxstylestrong{COMPLEX-VALUED NUMBERS}) for the use of direct/iterative parallel solvers

\item {} 
\sphinxhref{https://www.python.org/}{Python 3} (versions 3.5.2, 3.6.3 and 3.6.9 have been tested)

\item {} 
\sphinxhref{http://www.numpy.org/}{Numpy} for arrays manipulation

\item {} 
\sphinxhref{http://www.scipy.org/}{Scipy} for numerical operations

\item {} 
\sphinxhref{https://pypi.org/project/singleton-decorator/}{Singleton-decorator}

\item {} 
\sphinxhref{http://www.sphinx-doc.org}{Sphinx} and \sphinxhref{https://www.latex-project.org/}{LaTeX} (textlive) to generate documentation

\item {} 
\sphinxhref{https://bitbucket.org/petsc/petsc4py}{Petsc4py} for parallel computations on distributed-memory platforms. It allows the use of parallel direct/iterative solvers from \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc}

\item {} 
\sphinxhref{https://pypi.org/project/mpi4py/}{Mpi4py} for parallel computations on distributed-memory platforms.

\item {} 
\sphinxhref{https://pypi.org/project/h5py/}{h5py} for input/output tasks.

\end{itemize}

On Linux, consult the package manager of your preference. PETGEM can be
used without any installation by running the kernel from the top-level
directory of the distribution.


\section{Install PETGEM}
\label{\detokenize{Installation:install-petgem}}\label{\detokenize{Installation:install}}\begin{itemize}
\item {} 
Following commands may require root privileges

\item {} 
Download \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} (PETSc 3.7, 3.8, 3.9, 3.12, 3.14, and 3.17 have been tested)

\item {} 
Uncompress the \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} archive (in this example, using PETSc 3.17.0):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} tar zxvf petsc\PYGZhy{}3.17.0.tar.gz
\end{sphinxVerbatim}

\item {} 
Configure and build \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc}. The configuration options depend on the calculations you want to perform (complex- or real-valued) as well as your compiler/MPI/Blas/Lapack setup. For PETGEM executions, \sphinxstylestrong{PETSC MUST BE BUILD FOR COMPLEX-VALUED NUMBERS}. In order to avoid incompatibilities between PETSC, petsc4py and PETGEM, we highly recommend the following configuration lines. Please, visit \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} website for advanced configuration options. If you have a clean environment (not working MPI/Blas/Lapack), then run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} petsc\PYGZhy{}3.17.0
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{PETSC\PYGZus{}DIR}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PWD}
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{PETSC\PYGZus{}ARCH}\PYG{o}{=}arch\PYGZhy{}linux2\PYGZhy{}c\PYGZhy{}debug
\end{sphinxVerbatim}

\item {} 
If you do not want support for MUMPS, run following configure line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./configure \PYGZhy{}\PYGZhy{}with\PYGZhy{}cc\PYG{o}{=}gcc \PYGZhy{}\PYGZhy{}with\PYGZhy{}cxx\PYG{o}{=}g++ \PYGZhy{}\PYGZhy{}with\PYGZhy{}fc\PYG{o}{=}gfortran  \PYGZhy{}\PYGZhy{}download\PYGZhy{}mpich \PYGZhy{}\PYGZhy{}download\PYGZhy{}fblaslapack \PYGZhy{}\PYGZhy{}with\PYGZhy{}scalar\PYGZhy{}type\PYG{o}{=}complex
\end{sphinxVerbatim}

\item {} 
If you want support for MUMPS, please add following options to previous configure line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYGZhy{}\PYGZhy{}download\PYGZhy{}mumps \PYGZhy{}\PYGZhy{}download\PYGZhy{}scalapack \PYGZhy{}\PYGZhy{}download\PYGZhy{}parmetis \PYGZhy{}\PYGZhy{}download\PYGZhy{}metis \PYGZhy{}\PYGZhy{}download\PYGZhy{}ptscotch \PYGZhy{}\PYGZhy{}download\PYGZhy{}cmake
\end{sphinxVerbatim}

\item {} 
Further, to activate GPUs support, please add following options to previous configure line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYGZhy{}\PYGZhy{}with\PYGZhy{}cuda\PYG{o}{=}\PYG{l+m}{1} \PYGZhy{}\PYGZhy{}with\PYGZus{}cuda\PYGZus{}dir\PYG{o}{=}PATH
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{PATH}} is the directory of your CUDA libraries.

\item {} 
Then, build and install \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYG{n+nv}{\PYGZdl{}PETSC\PYGZus{}DIR} \PYG{n+nv}{\PYGZdl{}PETSC\PYGZus{}ARCH} all
\PYGZdl{} make \PYG{n+nv}{\PYGZdl{}PETSC\PYGZus{}DIR} \PYG{n+nv}{\PYGZdl{}PETSC\PYGZus{}ARCH} \PYG{n+nb}{test}
\PYGZdl{} make \PYG{n+nv}{\PYGZdl{}PETSC\PYGZus{}DIR} \PYG{n+nv}{\PYGZdl{}PETSC\PYGZus{}ARCH} streams
\end{sphinxVerbatim}

\item {} 
Ensure your \sphinxcode{\sphinxupquote{mpicc}} compiler wrapper is on your search path:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{PATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PETSC\PYGZus{}DIR}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{/}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PETSC\PYGZus{}ARCH}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{/bin:}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PATH}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
Ensure you have a \sphinxhref{http://www.numpy.org/}{Numpy} installed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip3 install numpy
\end{sphinxVerbatim}

\item {} 
And finally, install PETGEM with its dependencies (\sphinxhref{http://www.scipy.org/}{Scipy} , \sphinxhref{https://pypi.org/project/singleton-decorator/}{Singleton-decorator}, \sphinxhref{http://www.sphinx-doc.org}{Sphinx}, \sphinxhref{https://bitbucket.org/petsc/petsc4py}{Petsc4py}, \sphinxhref{https://pypi.org/project/mpi4py/}{Mpi4py}, \sphinxhref{https://pypi.org/project/h5py/}{h5py}) by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip3 install petgem
\end{sphinxVerbatim}

\end{itemize}


\section{Downloading and building PETGEM}
\label{\detokenize{Installation:downloading-and-building-petgem}}\label{\detokenize{Installation:downloadingbuildingpetgem}}
The PETGEM package is available for download at
\sphinxhref{https://pypi.python.org/pypi/petgem/}{Python Package Index (PyPI)}, at
\sphinxhref{https://github.com/ocastilloreyes/petgem}{GitHub},
and the {\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}} section of this project website.
\begin{itemize}
\item {} 
Configure and install \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} (see {\hyperref[\detokenize{Installation:install}]{\sphinxcrossref{\DUrole{std,std-ref}{Install PETGEM}}}} section)

\item {} 
Ensure you have a \sphinxhref{http://www.numpy.org/}{Numpy} installed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip3 install numpy
\end{sphinxVerbatim}

\item {} 
Download PETGEM (PETGEM 1.0.0 have been tested)

\item {} 
Uncompress the PETGEM archive:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} tar zxvf petgem\PYGZhy{}1.0.0.tar.gz
\PYGZdl{} \PYG{n+nb}{cd} petgem\PYGZhy{}1.0.0
\end{sphinxVerbatim}

\item {} 
After unpacking the release tarball, the distribution is ready for building. Some environment configuration is needed to inform the \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} location. As in {\hyperref[\detokenize{Installation:install}]{\sphinxcrossref{\DUrole{std,std-ref}{Install PETGEM}}}} section, you can set the environment variables \sphinxcode{\sphinxupquote{PETSC\_DIR}} and \sphinxcode{\sphinxupquote{PETSC\_ARCH}} indicating where you have built/installed \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{PETSC\PYGZus{}DIR}\PYG{o}{=}/usr/local/petsc
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{PETSC\PYGZus{}ARCH}\PYG{o}{=}arch\PYGZhy{}linux2\PYGZhy{}c\PYGZhy{}debug
\end{sphinxVerbatim}

\item {} 
Alternatively, you can edit the file \sphinxcode{\sphinxupquote{setup.cfg}} and provide the required information below \sphinxcode{\sphinxupquote{{[}config{]}}} section:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}config\PYG{o}{]}
\PYG{n+nv}{petsc\PYGZus{}dir} \PYG{o}{=} /usr/local/petsc
\PYG{n+nv}{petsc\PYGZus{}arch} \PYG{o}{=} arch\PYGZhy{}linux2\PYGZhy{}c\PYGZhy{}debug
\end{sphinxVerbatim}

\item {} 
Build the distribution by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python3 setup.py build
\end{sphinxVerbatim}

\item {} 
After building, the distribution is ready for installation (this option may require root privileges):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python3 setup.py install
\end{sphinxVerbatim}

\end{itemize}


\section{Build documentation}
\label{\detokenize{Installation:build-documentation}}\label{\detokenize{Installation:id2}}
PETGEM is documented in PDF and HTML format using \sphinxhref{http://www.sphinx-doc.org}{Sphinx} and
\sphinxhref{https://www.latex-project.org/}{LaTeX}. The documentation source
is in the \sphinxcode{\sphinxupquote{doc/}} directory. The following steps summarize how to generate PETGEM documentation.
\begin{itemize}
\item {} 
Move to the PETGEM doc directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} doc
\end{sphinxVerbatim}

\item {} 
Generate the PETGEM documentation in HTML format by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make html
\end{sphinxVerbatim}

\item {} 
Or, if you prefer the PDF format by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make latexpdf
\end{sphinxVerbatim}

\item {} 
The previous steps will build the documentation in the \sphinxcode{\sphinxupquote{doc/build}} directory. Alternatively, you can modify this path by editing the file \sphinxcode{\sphinxupquote{setup.cfg}} and provide the required information below \sphinxcode{\sphinxupquote{{[}build\_sphinx{]}}} section:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}build\PYGZus{}sphinx\PYG{o}{]}
source\PYGZhy{}dir \PYG{o}{=} doc/source
build\PYGZhy{}dir  \PYG{o}{=} usr/local/path\PYGZhy{}build
\PYG{n+nv}{all\PYGZus{}files}  \PYG{o}{=} \PYG{l+m}{1}
\end{sphinxVerbatim}

\end{itemize}


\chapter{Tutorial}
\label{\detokenize{Tutorial:tutorial}}\label{\detokenize{Tutorial:id1}}\label{\detokenize{Tutorial::doc}}
The PETGEM tutorial contains a small collection of programs which demonstrate
main aspects of the PETGEM work-flow. Each example has the
following structure:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{Readme.txt}}. Short description about what the example does.

\item {} 
\sphinxcode{\sphinxupquote{params.yaml}}. Physical parameters for the 3D CSEM/MT survey.

\item {} 
\sphinxcode{\sphinxupquote{petsc.opts}}. Parameters for \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} solvers.

\item {} 
Data for modeling (mesh, conductivity model and receivers list)

\end{enumerate}

The data for simple cases modelling are freely available in the
{\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}} section.


\section{Basic notions}
\label{\detokenize{Tutorial:basic-notions}}\label{\detokenize{Tutorial:id2}}
The use of PETGEM can be summarized in three steps: pre-processing, modelling and
post-processing. The pre-processing and modelling phases requires parameter files
where the physical conditions of the 3D CSEM/MT model are defined. In the
\sphinxcode{\sphinxupquote{params.yaml}} the 3D CSEM survey is described using several keywords
that allow one to define the main physical parameters and necessary file
locations. In sake of simplicity and in order to avoid a specific parser, the
\sphinxcode{\sphinxupquote{params.yaml}} file is defined as Python
dictionaries. Furthermore, the syntax of the \sphinxcode{\sphinxupquote{params.yaml}} file is very simple yet powerful. As consequence, the
dictionary names and his key names MUST NOT BE changed. See Preprocessing
parameters file description and Modelling parameters file description
in {\hyperref[\detokenize{Manual:manual}]{\sphinxcrossref{\DUrole{std,std-ref}{Manual}}}} section for a full explanation of those keywords.

For a general 3D CSEM/MT survey, the PETGEM work-flow can be summarize as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Following the contents of the \sphinxcode{\sphinxupquote{params.yaml}} file, a set of data are preprocessed (mesh, conductivity model and receivers positions) by the \sphinxcode{\sphinxupquote{kernel.py}}

\item {} 
A problem instance is created

\item {} 
The problem sets up its domain, sub-domains, source, solver. This stage include the computation of the main data structures

\item {} 
Parallel assembling of \(Ax=b\).

\item {} 
The solution is obtained in parallel by calling a \sphinxcode{\sphinxupquote{ksp()}} \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} object.

\item {} 
Interpolation of electromagnetic responses \& post-processing parallel stage

\item {} 
Finally the solution can be stored by calling \sphinxcode{\sphinxupquote{postprocess()}} method. Current version support hdf5.

\end{enumerate}

Based on previous work-flow, any 3D CSEM/MT modelling requires the following
input files:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A mesh file (current version supports Gmsh meshes)

\item {} 
A conductivity/resistivity model associated with the materials defined in the mesh file

\item {} 
A list of receivers positions in hdf5 format for the electromagnetic responses post-processing

\item {} 
A \sphinxcode{\sphinxupquote{params.yaml}} file where are defined the 3D CSEM/MT parameters

\item {} 
A \sphinxcode{\sphinxupquote{petsc.opts}} file where are defined options for \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} solvers

\item {} 
A \sphinxcode{\sphinxupquote{kernel.py}} script which manage the pre-processing and modelling tasks respectively

\end{enumerate}


\section{Running a simulation}
\label{\detokenize{Tutorial:running-a-simulation}}\label{\detokenize{Tutorial:running-a-simulation-tutorial}}
This section introduces the basics of running PETGEM on the command
line. Following command should be run in the top-level directory of the PETGEM
source tree.

PETGEM kernel is invoked as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mpirun \PYGZhy{}n MPI\PYGZus{}tasks python3 kernel.py \PYGZhy{}options\PYGZus{}file path/petsc.opts path/params.yaml
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{MPI\_tasks}} is the number of MPI parallel tasks, \sphinxcode{\sphinxupquote{kernel.py}} is
the script that manages the PETGEM work-flow, \sphinxcode{\sphinxupquote{petsc.opts}} is the
\sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} options file and \sphinxcode{\sphinxupquote{params.yaml}}
is the modelling parameters file for PETGEM.

A template of this file is included in \sphinxcode{\sphinxupquote{examples/}}
of the PETGEM source tree. Additionally, a freely available copy of this file
is located at {\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}} section.

See {\hyperref[\detokenize{Tutorial:model-parameters-file}]{\sphinxcrossref{\DUrole{std,std-ref}{Model parameters file}}}} section for more details about
\sphinxcode{\sphinxupquote{params.yaml}} file.


\section{Model parameters file}
\label{\detokenize{Tutorial:model-parameters-file}}\label{\detokenize{Tutorial:id5}}
By definition, any 3D CSEM/MT survey should include: physical parameters, a mesh
file, source and receivers files. These data are included in the
\sphinxcode{\sphinxupquote{params.yanl}} file. Additionally, options for
\sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} solvers are defined in a
\sphinxcode{\sphinxupquote{petsc.opts}} file.

In order to avoid a specific parser, \sphinxcode{\sphinxupquote{params.yaml}} file is imported by
PETGEM as a Python dictionary. As consequence, the dictionary name and his key names
MUST NOT BE changed.

A glance of \sphinxcode{\sphinxupquote{params.yaml}} file is the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} PETGEM parameters file}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Model parameters}
\PYG{n}{model}\PYG{p}{:}
  \PYG{n}{mode}\PYG{p}{:} \PYG{n}{csem}    \PYG{c+c1}{\PYGZsh{} Modeling mode: csem or mt}
  \PYG{n}{csem}\PYG{p}{:}
    \PYG{n}{sigma}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{}file: \PYGZsq{}my\PYGZus{}file.h5\PYGZsq{}                \PYGZsh{} Conductivity model file}
      \PYG{n}{horizontal}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{3.3333}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Horizontal conductivity}
      \PYG{n}{vertical}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{3.3333}\PYG{p}{]}    \PYG{c+c1}{\PYGZsh{} Vertical conductivity}
    \PYG{n}{source}\PYG{p}{:}
      \PYG{n}{frequency}\PYG{p}{:} \PYG{l+m+mf}{2.}                     \PYG{c+c1}{\PYGZsh{} Frequency (Hz)}
      \PYG{n}{position}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1750.}\PYG{p}{,} \PYG{l+m+mf}{1750.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{975.}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} Source position (xyz)}
      \PYG{n}{azimuth}\PYG{p}{:} \PYG{l+m+mf}{0.}                       \PYG{c+c1}{\PYGZsh{} Source rotation in xy plane (in degrees)}
      \PYG{n}{dip}\PYG{p}{:} \PYG{l+m+mf}{0.}                           \PYG{c+c1}{\PYGZsh{} Source rotation in xz plane (in degrees)}
      \PYG{n}{current}\PYG{p}{:} \PYG{l+m+mf}{1.}                       \PYG{c+c1}{\PYGZsh{} Source current (Am)}
      \PYG{n}{length}\PYG{p}{:} \PYG{l+m+mf}{1.}                        \PYG{c+c1}{\PYGZsh{} Source length  (m)}
  \PYG{n}{mt}\PYG{p}{:}
    \PYG{n}{sigma}\PYG{p}{:}
      \PYG{n}{file}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}file.h5}\PYG{l+s+s1}{\PYGZsq{}}                \PYG{c+c1}{\PYGZsh{} Conductivity model file}
      \PYG{c+c1}{\PYGZsh{}horizontal: [1.e\PYGZhy{}10, 0.01]       \PYGZsh{} Horizontal conductivity}
      \PYG{c+c1}{\PYGZsh{}vertical: [1.e\PYGZhy{}10, 0.01]         \PYGZsh{} Vertical conductivity}
    \PYG{n}{frequency}\PYG{p}{:} \PYG{l+m+mf}{4.}                      \PYG{c+c1}{\PYGZsh{} Frequency (Hz)}
    \PYG{n}{polarization}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}                 \PYG{c+c1}{\PYGZsh{} Polarization mode for mt (xyz)}

  \PYG{c+c1}{\PYGZsh{} Common parameters for all models}
  \PYG{n}{mesh}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}CSEM}\PYG{o}{/}\PYG{n}{DIPOLE1D}\PYG{o}{.}\PYG{n}{msh}   \PYG{c+c1}{\PYGZsh{} Mesh file (gmsh format v2)}
  \PYG{n}{receivers}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}CSEM}\PYG{o}{/}\PYG{n}{receiver\PYGZus{}pos}\PYG{o}{.}\PYG{n}{h5} \PYG{c+c1}{\PYGZsh{} Receiver positions file (xyz)}

\PYG{c+c1}{\PYGZsh{} Execution parameters}
\PYG{n}{run}\PYG{p}{:}
  \PYG{n}{nord}\PYG{p}{:} \PYG{l+m+mi}{1}       \PYG{c+c1}{\PYGZsh{} Vector basis order (1,2,3,4,5,6)}
  \PYG{n}{cuda}\PYG{p}{:} \PYG{k+kc}{False}   \PYG{c+c1}{\PYGZsh{} Cuda support (True or False)}

\PYG{c+c1}{\PYGZsh{} Output parameters}
\PYG{n}{output}\PYG{p}{:}
  \PYG{n}{vtk}\PYG{p}{:} \PYG{k+kc}{True}                               \PYG{c+c1}{\PYGZsh{} Postprocess vtk file (EM fields, conductivity)}
  \PYG{n}{directory}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}CSEM}\PYG{o}{/}\PYG{n}{out}           \PYG{c+c1}{\PYGZsh{} Directory for output (results)}
  \PYG{n}{directory\PYGZus{}scratch}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}CSEM}\PYG{o}{/}\PYG{n}{tmp}   \PYG{c+c1}{\PYGZsh{} Directory for temporal files}
\end{sphinxVerbatim}

A template of this file is included in \sphinxcode{\sphinxupquote{examples/}}
of the PETGEM source tree. Additionally, a freely available copy of this file
is located at {\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}} section. Furthermore, in
{\hyperref[\detokenize{Manual:running-a-simulation-manual}]{\sphinxcrossref{\DUrole{std,std-ref}{Running a simulation}}}} section of the PETGEM Manual is included
a deep description about this file.


\section{Visualization of results}
\label{\detokenize{Tutorial:visualization-of-results}}\label{\detokenize{Tutorial:visualization-of-results-tutorial}}
Once a solution of a 3D CSEM/MT survey has been obtained, it should be
post-processed by using a visualization program. PETGEM does not do the
visualization by itself, but it generates output file (hdf5 format is supported)
with the electromagnetic responses (Ex, Ey, Ez, Hx, Hy, Hz) for CSEM and the
apparent resistivities and phases for MT. It also gives timing values
in order to evaluate the performance.


\chapter{Manual}
\label{\detokenize{Manual:manual}}\label{\detokenize{Manual:id1}}\label{\detokenize{Manual::doc}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Table of contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Manual:id26}}{\hyperref[\detokenize{Manual:how-generate-documentation}]{\sphinxcrossref{How generate documentation}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id27}}{\hyperref[\detokenize{Manual:coding-style}]{\sphinxcrossref{Coding style}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id28}}{\hyperref[\detokenize{Manual:petgem-design}]{\sphinxcrossref{PETGEM design}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Manual:id29}}{\hyperref[\detokenize{Manual:petgem-directory-structure}]{\sphinxcrossref{PETGEM directory structure}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{Manual:id30}}{\hyperref[\detokenize{Manual:running-a-simulation}]{\sphinxcrossref{Running a simulation}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id31}}{\hyperref[\detokenize{Manual:mesh-formats}]{\sphinxcrossref{Mesh formats}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id32}}{\hyperref[\detokenize{Manual:available-solvers}]{\sphinxcrossref{Available solvers}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id33}}{\hyperref[\detokenize{Manual:simulations-in-parallel}]{\sphinxcrossref{Simulations in parallel}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id34}}{\hyperref[\detokenize{Manual:visualization-of-results}]{\sphinxcrossref{Visualization of results}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id35}}{\hyperref[\detokenize{Manual:csem-example}]{\sphinxcrossref{CSEM example}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Manual:id36}}{\hyperref[\detokenize{Manual:example-1-canonical-model-of-an-off-shore-hydrocarbon-reservoir}]{\sphinxcrossref{Example 1: Canonical model of an off-shore hydrocarbon reservoir}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Manual:id37}}{\hyperref[\detokenize{Manual:model}]{\sphinxcrossref{Model}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id38}}{\hyperref[\detokenize{Manual:meshing}]{\sphinxcrossref{Meshing}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id39}}{\hyperref[\detokenize{Manual:parameters-file-for-petgem}]{\sphinxcrossref{Parameters file for PETGEM}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id40}}{\hyperref[\detokenize{Manual:running-petgem}]{\sphinxcrossref{Running PETGEM}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id41}}{\hyperref[\detokenize{Manual:petgem-post-processing}]{\sphinxcrossref{PETGEM post-processing}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{Manual:id42}}{\hyperref[\detokenize{Manual:example-2-use-of-high-order-nedelec-elements}]{\sphinxcrossref{Example 2: Use of high-order Nédélec elements}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Manual:id43}}{\hyperref[\detokenize{Manual:id8}]{\sphinxcrossref{Meshing}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id44}}{\hyperref[\detokenize{Manual:id9}]{\sphinxcrossref{Parameters file for PETGEM}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id45}}{\hyperref[\detokenize{Manual:id10}]{\sphinxcrossref{Running PETGEM}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id46}}{\hyperref[\detokenize{Manual:nedelec-order-comparison}]{\sphinxcrossref{Nédélec order comparison}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{Manual:id47}}{\hyperref[\detokenize{Manual:example-3-use-of-petsc-solvers}]{\sphinxcrossref{Example 3: Use of PETSc solvers}}}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{Manual:id48}}{\hyperref[\detokenize{Manual:mt-example}]{\sphinxcrossref{MT example}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Manual:id49}}{\hyperref[\detokenize{Manual:example-4-3d-trapezoidal-hill-model}]{\sphinxcrossref{Example 4: 3D trapezoidal hill model}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Manual:id50}}{\hyperref[\detokenize{Manual:id12}]{\sphinxcrossref{Model}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id51}}{\hyperref[\detokenize{Manual:id13}]{\sphinxcrossref{Parameters file for PETGEM}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id52}}{\hyperref[\detokenize{Manual:id14}]{\sphinxcrossref{Running PETGEM}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id53}}{\hyperref[\detokenize{Manual:id15}]{\sphinxcrossref{PETGEM post-processing}}}

\end{itemize}

\end{itemize}

\item {} 
\phantomsection\label{\detokenize{Manual:id54}}{\hyperref[\detokenize{Manual:code-documentation}]{\sphinxcrossref{Code documentation}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{Manual:id55}}{\hyperref[\detokenize{Manual:kernel}]{\sphinxcrossref{kernel}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id56}}{\hyperref[\detokenize{Manual:common-scripts}]{\sphinxcrossref{Common scripts}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id57}}{\hyperref[\detokenize{Manual:pre-processing}]{\sphinxcrossref{Pre-processing}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id58}}{\hyperref[\detokenize{Manual:mesh-scripts}]{\sphinxcrossref{Mesh scripts}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id59}}{\hyperref[\detokenize{Manual:hefem-scripts}]{\sphinxcrossref{HEFEM scripts}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id60}}{\hyperref[\detokenize{Manual:solver}]{\sphinxcrossref{Solver}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id61}}{\hyperref[\detokenize{Manual:parallel}]{\sphinxcrossref{Parallel}}}

\item {} 
\phantomsection\label{\detokenize{Manual:id62}}{\hyperref[\detokenize{Manual:post-processing}]{\sphinxcrossref{Post-processing}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}

This manual provides reference documentation to PETGEM from a user’s and
developer’s perspective.


\section{How generate documentation}
\label{\detokenize{Manual:how-generate-documentation}}\label{\detokenize{Manual:id2}}
PETGEM is documented in PDF and HTML format using \sphinxhref{http://www.sphinx-doc.org}{Sphinx} and
\sphinxhref{https://www.latex-project.org/}{LaTeX}. The documentation source
is in the \sphinxcode{\sphinxupquote{doc/}} directory. The following steps summarize how to generate PETGEM documentation.
\begin{itemize}
\item {} 
Move to the PETGEM doc directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} doc
\end{sphinxVerbatim}

\item {} 
Generate the PETGEM documentation in HTML format by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make html
\end{sphinxVerbatim}

\item {} 
Or, if you prefer the PDF format by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make latexpdf
\end{sphinxVerbatim}

\item {} 
The previous steps will build the documentation in the \sphinxcode{\sphinxupquote{doc/build}} directory. Alternatively, you can modify this path by editing the file \sphinxcode{\sphinxupquote{setup.cfg}} and provide the required information below \sphinxcode{\sphinxupquote{{[}build\_sphinx{]}}} section:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}build\PYGZus{}sphinx\PYG{o}{]}
source\PYGZhy{}dir \PYG{o}{=} doc/source
build\PYGZhy{}dir  \PYG{o}{=} usr/local/path\PYGZhy{}build
\PYG{n+nv}{all\PYGZus{}files}  \PYG{o}{=} \PYG{l+m}{1}
\end{sphinxVerbatim}

\end{itemize}


\section{Coding style}
\label{\detokenize{Manual:coding-style}}\label{\detokenize{Manual:id3}}
PETGEM’s coding style is based on
\sphinxhref{https://www.python.org/dev/peps/pep-0008/}{PEP-0008} guidelines. Main
guidelines are the following:
\begin{itemize}
\item {} 
79 characteres per line.

\item {} 
4 spaces per indentation level.

\item {} 
Variables are lower case meanwhile constants are upper case.

\item {} 
Comments convention for functions is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
def \PYG{k}{function}\PYG{o}{(}arg1, arg2\PYG{o}{)}:
    \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{} This is a function.}

\PYG{l+s+s1}{        :param int arg1: array of dimensions ...}
\PYG{l+s+s1}{        :param str arg2: string that ...}
\PYG{l+s+s1}{    \PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
The use of inline comments is sparingly.

\item {} 
Use of lowercase to name functions. Furthermore, functions names have following form: \sphinxcode{\sphinxupquote{\textless{}actionSubject\textgreater{}()}}, e.g. \sphinxcode{\sphinxupquote{computeMatrix()}}.

\item {} 
Use of whole words instead abbreviations, examples:
\begin{itemize}
\item {} 
Yes: \sphinxcode{\sphinxupquote{solveSystem()}}, \sphinxcode{\sphinxupquote{computeEdges()}}, \sphinxcode{\sphinxupquote{computeMatrix()}}.

\item {} 
No: \sphinxcode{\sphinxupquote{solve()}}, \sphinxcode{\sphinxupquote{compEdges()}}, \sphinxcode{\sphinxupquote{compMatrix()}}.

\end{itemize}

\end{itemize}


\section{PETGEM design}
\label{\detokenize{Manual:petgem-design}}\label{\detokenize{Manual:id4}}
PETGEM use a code structure for the high-order Nédelec FE algorithm that emphasizes
good parallel scalability, which is crucial in the multi-core era.
Furthermore, it’s modularity should simplify the process of reaching the
best possible performance in terms of percentage of the peak amount of
floating point operations provided by the architecture. The code structure is
modular, simple and flexible which allows exploiting not just PETGEM modules
but also third party libraries. Therefore, the software stack includes
interfaces to external suites of data structures and libraries that contain
most of the necessary building blocks needed for programming large scale
numerical applications, i.e. sparse matrices, vectors, iterative and direct
solvers. As a result, the code is compact and
flexible whose main UML diagrams are described as follows.


\subsection{PETGEM directory structure}
\label{\detokenize{Manual:petgem-directory-structure}}
This subsection is dedicated to list and describe the PETGEM directory
structure.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Top directory structure}\label{\detokenize{Manual:id17}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{10}{100}|\X{90}{100}|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxtitleref{doc/}
&
Source files for PETGEM documentation
\\
\hline
\sphinxtitleref{examples/}
&
Templates of basic scripts for 3D CSEM/MT modelling
\\
\hline
\sphinxtitleref{petgem/}
&
Source code
\\
\hline
\sphinxtitleref{kernel.py}
&
Heart of the code. This file contains the entire work-flow for a
3D CSEM/MT survey
\\
\hline
\sphinxtitleref{DESCRIPTION.rst}
&
Summary of PETGEM features, requirements and installation instructions
\\
\hline
\sphinxtitleref{LICENSE.rst}
&
License file
\\
\hline
\sphinxtitleref{MANIFEST.in}
&
File with exact list of files to include in PETGEM distribution
\\
\hline
\sphinxtitleref{README.rst}
&
Readme file
\\
\hline
\sphinxtitleref{setup.py}
&
Main PETGEM setup script, it is based on Python setup-module
\\
\hline
\sphinxtitleref{setup.cfg}
&
Setup configuration file for PETGEM setup script
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

The PETGEM source code is \sphinxtitleref{petgem/}, which has the following contents:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{\sphinxtitleref{petgem/} directory structure}\label{\detokenize{Manual:id18}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{10}{100}|\X{90}{100}|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxtitleref{common.py}
&
Common classes and functions for init process.
\\
\hline
\sphinxtitleref{hvfem.py}
&
General modules and classes for describing a 3D CSEM/MT survey by using HEFEM (\(p=1,2,3,4,5,6\)) in tetrahedral meshes
\\
\hline
\sphinxtitleref{mesh.py}
&
Interface to import mesh files
\\
\hline
\sphinxtitleref{parallel.py}
&
Modules for supporting parallel computations and solution of 3D CSEM/MT
\\
\hline
\sphinxtitleref{preprocessing.py}
&
Modules for PETGEM pre-processing
\\
\hline
\sphinxtitleref{solver.py}
&
Parallel functions within PETGEM and interface to \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} solvers
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Running a simulation}
\label{\detokenize{Manual:running-a-simulation}}\label{\detokenize{Manual:running-a-simulation-manual}}
This section introduces the basics of running PETGEM on the command
line. In order to solve a 3D CSEM/MT survey, the PETGEM kernel requires two
files, namely, the \sphinxcode{\sphinxupquote{petsc.opts}} file and the \sphinxcode{\sphinxupquote{params.yaml}} file, which
are described below.

Options for \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} solvers/preconditioners
are accessible via the \sphinxcode{\sphinxupquote{petsc.opts}} file, a glance of this is the
following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for PETSc}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}type} \PYG{n}{gmres}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{sor}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}rtol} \PYG{l+m+mf}{1e\PYGZhy{}8}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}converged\PYGZus{}reason}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}monitor}
\end{sphinxVerbatim}

Please, see \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} documentation for more
details about available options. A template of this file is included in
\sphinxcode{\sphinxupquote{examples/}} of the PETGEM source tree. Additionally, a freely
available copy of this file is located at {\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}} section.

On the other hand, any 3D CSEM/MT survey should include: order for Nédélec elements
discretizations, physical parameters,
a mesh file, source and receivers files. These data are included in the
\sphinxcode{\sphinxupquote{params.yaml}} file. In order to avoid a specific parser, \sphinxcode{\sphinxupquote{params.yaml}}
file is imported by PETGEM as a Python dictionary. As consequence, the
dictionary name and his key names MUST NOT BE changed.

A glance of \sphinxcode{\sphinxupquote{params.yaml}} file is the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} PETGEM parameters file}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Model parameters}
\PYG{n}{model}\PYG{p}{:}
  \PYG{n}{mode}\PYG{p}{:} \PYG{n}{mt}    \PYG{c+c1}{\PYGZsh{} Modeling mode: csem or mt}
  \PYG{n}{csem}\PYG{p}{:}
    \PYG{n}{sigma}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{}file: \PYGZsq{}my\PYGZus{}file.h5\PYGZsq{}                \PYGZsh{} Conductivity model file}
      \PYG{n}{horizontal}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}       \PYG{c+c1}{\PYGZsh{} Horizontal conductivity}
      \PYG{n}{vertical}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}         \PYG{c+c1}{\PYGZsh{} Vertical conductivity}
    \PYG{n}{source}\PYG{p}{:}
      \PYG{n}{frequency}\PYG{p}{:} \PYG{l+m+mf}{2.}                     \PYG{c+c1}{\PYGZsh{} Frequency (Hz)}
      \PYG{n}{position}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1750.}\PYG{p}{,} \PYG{l+m+mf}{1750.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{975.}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} Source position (xyz)}
      \PYG{n}{azimuth}\PYG{p}{:} \PYG{l+m+mf}{0.}                       \PYG{c+c1}{\PYGZsh{} Source rotation in xy plane (in degrees)}
      \PYG{n}{dip}\PYG{p}{:} \PYG{l+m+mf}{0.}                           \PYG{c+c1}{\PYGZsh{} Source rotation in xz plane (in degrees)}
      \PYG{n}{current}\PYG{p}{:} \PYG{l+m+mf}{1.}                       \PYG{c+c1}{\PYGZsh{} Source current (Am)}
      \PYG{n}{length}\PYG{p}{:} \PYG{l+m+mf}{1.}                        \PYG{c+c1}{\PYGZsh{} Source length  (m)}
  \PYG{n}{mt}\PYG{p}{:}
    \PYG{n}{sigma}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{}file: \PYGZsq{}my\PYGZus{}file.h5\PYGZsq{}                \PYGZsh{} Conductivity model file}
      \PYG{n}{horizontal}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}       \PYG{c+c1}{\PYGZsh{} Horizontal conductivity}
      \PYG{n}{vertical}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}         \PYG{c+c1}{\PYGZsh{} Vertical conductivity}
    \PYG{n}{frequency}\PYG{p}{:} \PYG{l+m+mf}{2.}                      \PYG{c+c1}{\PYGZsh{} Frequency (Hz)}
    \PYG{n}{polarization}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}                 \PYG{c+c1}{\PYGZsh{} Polarization mode for mt (xyz)}

  \PYG{c+c1}{\PYGZsh{} Common parameters for all models}
  \PYG{n}{mesh}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}MT}\PYG{o}{/}\PYG{n}{mesh\PYGZus{}trapezoidal}\PYG{o}{.}\PYG{n}{msh}   \PYG{c+c1}{\PYGZsh{} Mesh file (gmsh format v2)}
  \PYG{n}{receivers}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}MT}\PYG{o}{/}\PYG{n}{receivers}\PYG{o}{.}\PYG{n}{h5} \PYG{c+c1}{\PYGZsh{} Receiver positions file (xyz)}

\PYG{c+c1}{\PYGZsh{} Execution parameters}
\PYG{n}{run}\PYG{p}{:}
  \PYG{n}{nord}\PYG{p}{:} \PYG{l+m+mi}{1}       \PYG{c+c1}{\PYGZsh{} Vector basis order (1,2,3,4,5,6)}
  \PYG{n}{cuda}\PYG{p}{:} \PYG{k+kc}{False}   \PYG{c+c1}{\PYGZsh{} Cuda support (True or False)}

\PYG{c+c1}{\PYGZsh{} Output parameters}
\PYG{n}{output}\PYG{p}{:}
  \PYG{n}{vtk}\PYG{p}{:} \PYG{k+kc}{False}                               \PYG{c+c1}{\PYGZsh{} Postprocess vtk file (EM fields, conductivity)}
  \PYG{n}{directory}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}MT}\PYG{o}{/}\PYG{n}{out}           \PYG{c+c1}{\PYGZsh{} Directory for output (results)}
  \PYG{n}{directory\PYGZus{}scratch}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}MT}\PYG{o}{/}\PYG{n}{tmp}   \PYG{c+c1}{\PYGZsh{} Directory for temporal files}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{params.yaml}} file is divided into 3 sections, namely, model,
run and output.

A template of \sphinxcode{\sphinxupquote{params.yaml}} file is included in \sphinxcode{\sphinxupquote{examples/}}
of the PETGEM source tree. Additionally, a freely available copy of this file
is located at {\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}} section.

Once the \sphinxcode{\sphinxupquote{petsc.opts}} file and the \sphinxcode{\sphinxupquote{params.yaml}} file are ready, the
PETGEM kernel is invoked as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mpirun \PYGZhy{}n MPI\PYGZus{}tasks python3 kernel.py \PYGZhy{}options\PYGZus{}file path/petsc.opts path/params.yaml
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{MPI\_tasks}} is the number of MPI parallel tasks, \sphinxcode{\sphinxupquote{kernel.py}} is
the script that manages the PETGEM work-flow, \sphinxcode{\sphinxupquote{petsc.opts}} is the
\sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} options file and \sphinxcode{\sphinxupquote{params.yaml}}
is the modelling parameters file for PETGEM.

PETGEM solves the problem and outputs the solution to the \sphinxcode{\sphinxupquote{output.directory/}} path.
The output file will be in h5py format. By default, the file structure contains a
\sphinxcode{\sphinxupquote{fields}} dataset and a \sphinxcode{\sphinxupquote{receiver\_coordinates}} dataset. In example, if the
model has 3 receivers, \sphinxcode{\sphinxupquote{fields}} dataset would contain six components (Ex, Ey, Ez, Hx, Hy, Hz)
of the electromagnetic field responses as follows (\sphinxcode{\sphinxupquote{fields}} only for illustrative
purposes):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYG{n}{Ex}\PYG{o}{\PYGZhy{}}\PYG{n}{component}               \PYG{n}{Ey}\PYG{o}{\PYGZhy{}}\PYG{n}{component}              \PYG{n}{Ez}\PYG{o}{\PYGZhy{}}\PYG{n}{component}                 \PYG{n}{Hx}\PYG{o}{\PYGZhy{}}\PYG{n}{component}             \PYG{n}{Hy}\PYG{o}{\PYGZhy{}}\PYG{n}{component}              \PYG{n}{Hz}\PYG{o}{\PYGZhy{}}\PYG{n}{component}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5574e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{7.1233e\PYGZhy{}13}\PYG{n}{j}       \PYG{l+m+mf}{4.6739e\PYGZhy{}14}\PYG{o}{+}\PYG{l+m+mf}{2.5366e\PYGZhy{}14}\PYG{n}{j}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.1475e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{3.7062e\PYGZhy{}13}\PYG{n}{j}     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5574e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{7.1233e\PYGZhy{}13}\PYG{n}{j}   \PYG{l+m+mf}{4.6739e\PYGZhy{}14}\PYG{o}{+}\PYG{l+m+mf}{2.5366e\PYGZhy{}14}\PYG{n}{j}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.1475e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{3.7062e\PYGZhy{}13}\PYG{n}{j}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.3279e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{7.1644e\PYGZhy{}13}\PYG{n}{j}       \PYG{l+m+mf}{9.0092e\PYGZhy{}14}\PYG{o}{+}\PYG{l+m+mf}{5.6392e\PYGZhy{}14}\PYG{n}{j}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.3662e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{3.7808e\PYGZhy{}13}\PYG{n}{j}     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.3279e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{7.1644e\PYGZhy{}13}\PYG{n}{j}   \PYG{l+m+mf}{9.0092e\PYGZhy{}14}\PYG{o}{+}\PYG{l+m+mf}{5.6392e\PYGZhy{}14}\PYG{n}{j}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.3662e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{3.7808e\PYGZhy{}13}\PYG{n}{j}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0010e\PYGZhy{}12}\PYG{o}{+}\PYG{l+m+mf}{7.0402e\PYGZhy{}13}\PYG{n}{j}       \PYG{l+m+mf}{1.0689e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{3.6703e\PYGZhy{}14}\PYG{n}{j}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.8662e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{3.6350e\PYGZhy{}13}\PYG{n}{j}     \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0010e\PYGZhy{}12}\PYG{o}{+}\PYG{l+m+mf}{7.0402e\PYGZhy{}13}\PYG{n}{j}   \PYG{l+m+mf}{1.0689e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{3.6703e\PYGZhy{}14}\PYG{n}{j}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.8662e\PYGZhy{}13}\PYG{o}{+}\PYG{l+m+mf}{3.6350e\PYGZhy{}13}\PYG{n}{j}
\end{sphinxVerbatim}

It is worth to mention the fields will be separated by real and imaginary component.On
the other hand, the receiver coordinates as follows (\sphinxcode{\sphinxupquote{receiver\_coordinates}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  \PYG{n}{X}         \PYG{n}{Y}                   \PYG{n}{Z}
\PYG{l+m+mf}{1750.}          \PYG{l+m+mf}{1750.}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{990}
\PYG{l+m+mf}{1800.}          \PYG{l+m+mf}{1750.}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{990}
\PYG{l+m+mf}{1850.}          \PYG{l+m+mf}{1750.}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{990}
\end{sphinxVerbatim}

In summary, for a general 3D CSEM/MT survey, the \sphinxcode{\sphinxupquote{kernel.py}} script follows
the next work-flow:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxcode{\sphinxupquote{kernel.py}} reads a \sphinxcode{\sphinxupquote{params.yaml}}

\item {} 
Following the contents of the \sphinxcode{\sphinxupquote{params.yaml}}, a problem instance is created

\item {} 
Runs the data preprocessing

\item {} 
The problem sets up its domain, sub-domains, source-type, solver. This stage include the computation of the main data structures

\item {} 
Parallel assembling of \(Ax=b\).

\item {} 
The solution is obtained in parallel by calling a \sphinxcode{\sphinxupquote{ksp()}} \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} object.

\item {} 
Interpolation of electromagnetic (electric and magnetic) responses and post-processing parallel stage

\item {} 
Finally the solution can be stored by calling \sphinxcode{\sphinxupquote{solver.postprocess()}} method. Current version support \sphinxhref{https://pypi.org/project/h5py/}{h5py} format.

\end{enumerate}

Based on previous work-flow, any 3D CSEM/MT modelling requires the following
input files:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A mesh file (current version supports mesh files from \sphinxhref{http://gmsh.info/}{Gmsh})

\item {} 
A conductivity model associated with the materials defined in the mesh file

\item {} 
A list of receivers positions in hdf5 format for the electric responses post-processing

\item {} 
A \sphinxcode{\sphinxupquote{params.yaml}} file where are defined the 3D CSEM/MT parameters

\item {} 
A \sphinxcode{\sphinxupquote{petsc.opts}} file where are defined options for \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} solvers

\end{enumerate}

During the preprocessing stage, the \sphinxcode{\sphinxupquote{kernel.py}} generates the mesh file (\sphinxhref{http://gmsh.info/}{Gmsh} format) with its
conductivity model and receivers positions in \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} binary files.

For this phase, the supported/expected formats are the following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{basis\_order}}: nédélec basis element order for the discretization. Supported orders are \(p=1,2,3,4,5,6\)

\item {} 
\sphinxcode{\sphinxupquote{mesh\_file}}: path to tetrahedral mesh file in format from \sphinxhref{http://gmsh.info/}{Gmsh}

\item {} 
\sphinxcode{\sphinxupquote{sigma}}: numpy array or hdf5 file where each value represents the horizontal and vertical conductivity for each material defined in \sphinxcode{\sphinxupquote{mesh\_file}}. Therefore, size of \sphinxcode{\sphinxupquote{sigma}} must match with the number of materials in \sphinxcode{\sphinxupquote{mesh\_file}}

\item {} 
\sphinxcode{\sphinxupquote{receivers\_file}}: floating point values giving the X, Y and Z coordinates of each receiver in hdf5 format. Therefore, the number of receivers in the modelling will defined the number of the rows in \sphinxcode{\sphinxupquote{receivers\_file}}, i.e. if the modelling has 3 receivers, \sphinxcode{\sphinxupquote{receivers\_file}} should be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{5.8333300e+01}   \PYG{l+m+mf}{1.7500000e+03}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.9000000e+02}
\PYG{l+m+mf}{1.1666670e+02}   \PYG{l+m+mf}{1.7500000e+03}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.9000000e+02}
\PYG{l+m+mf}{1.7500000e+02}   \PYG{l+m+mf}{1.7500000e+03}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.9000000e+02}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{output\_directory\_scratch}}: output scratch directory for pre-processing task

\end{itemize}

Once the previous information has been provided, the \sphinxcode{\sphinxupquote{kernel.py}}
script will generate all the input files required by PETGEM in order to
solve a 3D CSEM/MT survey. The \sphinxcode{\sphinxupquote{kernel.py}} output files list is the
following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nodes.dat}}: floating point values giving the X, Y and Z coordinates of the four nodes that make up each tetrahedral element in the mesh. The dimensions of \sphinxcode{\sphinxupquote{nodes.dat}} are given by (number-of-elements, 12)

\item {} 
\sphinxcode{\sphinxupquote{meshConnectivity.dat}}: list of the node number of the n-th tetrahedral element in the mesh. The dimensions of \sphinxcode{\sphinxupquote{meshConnectivity.dat}} are given by (number-of-elements, 4)

\item {} 
\sphinxcode{\sphinxupquote{dofs.dat}}: list of degrees of freedom of the n-th tetrahedral element in the mesh. Since PETGEM is based on high-order Nédelec FE, the dimensions of \sphinxcode{\sphinxupquote{dofs.dat}} are given by (number-of-elements, 6) for \(p=1\), by (number-of-elements, 20) for \(p=2\), by (number-of-elements, 45) for \(p=3\), by (number-of-elements, 84) for \(p=4\), by (number-of-elements, 140) for \(p=5\), and by (number-of-elements, 216) for \(p=6\).

\item {} 
\sphinxcode{\sphinxupquote{edges.dat}}: list of the edges number of the n-th tetrahedral element in the mesh. The dimensions of \sphinxcode{\sphinxupquote{edges.dat}} are given by (number-of-elements, 6)

\item {} 
\sphinxcode{\sphinxupquote{faces.dat}}: list of the faces number of the n-th tetrahedral element in the mesh. The dimensions of \sphinxcode{\sphinxupquote{faces.dat}} are given by (number-of-elements, 4)

\item {} 
\sphinxcode{\sphinxupquote{edgesNodes.dat}}: list of the two nodes that make up each edge in the mesh. The dimensions of \sphinxcode{\sphinxupquote{edgesNodes.dat}} are given by (number-of-edges, 2)

\item {} 
\sphinxcode{\sphinxupquote{faces.dat}}: list of the four faces that make up each tetrahedral element in the mesh. The dimensions of \sphinxcode{\sphinxupquote{faces.dat}} are given by (number-of-elements, 4)

\item {} 
\sphinxcode{\sphinxupquote{facesNodes.dat}}: list of the three nodes that make up each tetrahedral face in the mesh. The dimensions of \sphinxcode{\sphinxupquote{facesNodes.dat}} are given by (number-of-faces, 3)

\item {} 
\sphinxcode{\sphinxupquote{boundaries.dat}}: list of the DOFs indexes that belongs on domain boundaries. The dimensions of \sphinxcode{\sphinxupquote{boundaries.dat}} are given by (number-of-boundaries, 1)

\item {} 
\sphinxcode{\sphinxupquote{conductivityModel.dat}}: floating point values giving the conductivity to which the n-th tetrahedral element belongs. The dimensions of \sphinxcode{\sphinxupquote{conductivityModel.dat}} are given by (number-of-elements, 1)

\item {} 
\sphinxcode{\sphinxupquote{receivers.dat}}: floating point values giving the X, Y and Z coordinates of the receivers. Additionally, this file includes information about the tetrahedral element that contains the n-th receiver, namely, its X, Y and Z coordinates of the four nodes, its list of the node number and its list of DOFs.

\item {} 
\sphinxcode{\sphinxupquote{nnz.dat}}: list containing the number of nonzeros in the various matrix rows, namely, the sparsity pattern. According to the \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} documentation, using the \sphinxcode{\sphinxupquote{nnz.dat}} list to preallocate memory is especially important for efficient matrix assembly if the number of nonzeros varies considerably among the rows. The dimensions of \sphinxcode{\sphinxupquote{nnz.dat}} are given by (number-of-DOFs, 1)

\end{itemize}

For each \sphinxcode{\sphinxupquote{*.dat}} output file, the \sphinxcode{\sphinxupquote{kernel.py}} script will
generate \sphinxcode{\sphinxupquote{*.info}} files which are \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc}
control information.

For post-processing stage (interpolation of electric responses at receivers
positions) a point location function is needed. For this task, PETGEM is based
on \sphinxcode{\sphinxupquote{find\_simplex}} function by \sphinxhref{https://docs.scipy.org/doc/}{Scipy}, which
find the tetrahedral elements (simplices) containing the given receivers
points. If some receivers positions are not found, PETGEM will print its
indexes and will save only those located points in the \sphinxcode{\sphinxupquote{receivers.dat}}
file.


\section{Mesh formats}
\label{\detokenize{Manual:mesh-formats}}\label{\detokenize{Manual:id5}}
Current PETGEM version supports mesh files from
\sphinxhref{http://gmsh.info/}{Gmsh}. Aforementioned format must be pre-processed
using the \sphinxcode{\sphinxupquote{run\_preprocessing.py}} script. The \sphinxcode{\sphinxupquote{run\_preprocessing.py}}
script is included in the top-level directory of the PETGEM source tree.


\section{Available solvers}
\label{\detokenize{Manual:available-solvers}}\label{\detokenize{Manual:id6}}
This section describes solvers available in PETGEM from an user’s perspective.
Direct as well as iterative solvers and preconditioners are supported
through an interface to \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} library.

PETGEM uses \sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py} package in
order to support the Krylov Subspace Package (KSP) from
\sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc}. The object KSP provides an
easy-to-use interface to the combination of a parallel Krylov iterative method
and a preconditioner (PC) or a sequential/parallel direct solver. As result,
PETGEM users can set various solver options and preconditioner
options at runtime via the \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} options
database. These parameters are defined in the \sphinxcode{\sphinxupquote{petsc.opts}} file.


\section{Simulations in parallel}
\label{\detokenize{Manual:simulations-in-parallel}}\label{\detokenize{Manual:id7}}
In FEM or HEFEM simulations, the need for efficient algorithms for assembling the
matrices may be crucial, especially when the DOFs is considerably large. This
is the case for realistic scenarios of 3D CSEM surveys because the required
accuracy. In such situation, assembly process remains a critical portion of
the code optimization since solution of linear systems which asymptotically
dominates in large-scale computing, could be done with linear solvers such
as \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc},
\sphinxhref{http://mumps.enseeiht.fr/}{MUMPs},
\sphinxhref{http://www.pardiso-project.org/}{PARDISO}). In fact, in PETGEM V0.6,
the system assembly takes around \$15\%\$ of the total time.

The classical assembly in FEM or HEFEM programming is based on a loop over the
elements. Different techniques and algorithms have been proposed and nowadays is
possible performing these computations at the same time, i.e., to compute them in
parallel. However, parallel programming is not a trivial task in most programming
languages, and demands a strong theoretical knowledge about the hardware
architecture. Fortunately, \sphinxhref{https://www.python.org/}{Python} presents user
friendly solutions for parallel computations, namely,
\sphinxhref{https://pypi.python.org/pypi/mpi4py}{mpi4py} and
\sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py} . These open-source
packages provides bindings of the MPI standard and the
\sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} library for the
\sphinxhref{https://www.python.org/}{Python} programming language, allowing
any \sphinxhref{https://www.python.org/}{Python} code to exploit multiple processors
architectures.

On top of that, {\hyperref[\detokenize{Manual:figure-7-4}]{\sphinxcrossref{Figure 7.4}}} depicts shows an upper view of the matrix assembly
and solution using the \sphinxhref{https://pypi.python.org/pypi/mpi4py}{mpi4py} and
\sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py} package in PETGEM. The first
step is to partition the work-load into subdomains. This task can be done
by \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} library, which makes load over
processes balanced. After domain partition, subdomains are assigned to MPI
tasks and the elemental matrices are calculated concurrently. These local
contributions are then accumulated into the global matrix system. The
process for global vector assembly is similar.

Subsequently, the system is ready to be solved. PETGEM uses the Krylov
Subspace Package (KSP) from \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} through
the \sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py} package. The KSP object
provides an easy-to-use interface to the combination of a parallel Krylov
iterative method and a preconditioner (PC) or a sequential/parallel direct
solver. As result, PETGEM users can set various solver options and
preconditioner options at runtime via the
\sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} options database. Since
\sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} knows which portions of the matrix
and vectors are locally owned by each processor, the post-processing task
is also completed in parallel.

All \sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py} classes and
methods are called from the PETGEM kernel in a manner that allows a
parallel matrix and parallel vectors to be created automatically when the
code is run on many processors. Similarly, if only one processor is specified
the code will run in a sequential mode. Although
\sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py} allows control the way
in which the matrices and vectors to be split across the processors
on the architecture, PETGEM simply let
\sphinxhref{https://pypi.python.org/pypi/petsc4py}{petsc4py} decide the local sizes
in sake of computational flexibility. However, this can be modified in an
easy way without any extra coding required.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.7]{{PETGEM_parallel_scheme}.png}
\caption{Figure 7.4. Parallel scheme for assembly and solution in PETGEM using 4 MPI tasks. Here the elemental matrices computation is done in parallel. After calculations the global system is built and solved in parallel using the petsc4py and mpi4py packages.}\label{\detokenize{Manual:id19}}\label{\detokenize{Manual:figure-7-4}}\end{figure}


\section{Visualization of results}
\label{\detokenize{Manual:visualization-of-results}}\label{\detokenize{Manual:visualization-of-results-manual}}
Once a solution of a 3D CSEM/MT survey has been obtained, it should be
post-processed by using a visualization program. PETGEM does not do the
visualization by itself, but it generates output files (hdf5 and VTK are supported)
with the electric responses at receivers positions and nodes in the mesh. It also gives timing values
in order to evaluate the performance.

{\hyperref[\detokenize{Manual:figure-7-5}]{\sphinxcrossref{Figure 7.5}}} shows an example of PETGEM output for the first modelling case
(Canonical model of an off-shore hydrocarbon reservoir) described in
{\hyperref[\detokenize{Manual:examples}]{\sphinxcrossref{\DUrole{std,std-ref}{CSEM example}}}} section. {\hyperref[\detokenize{Manual:figure-7-5}]{\sphinxcrossref{Figure 7.5}}} was obtained using
\sphinxhref{http://www.paraview.org/}{Paraview}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{totalFieldVTK}.png}
\caption{Figure 7.5. PETGEM vtk output.}\label{\detokenize{Manual:id20}}\label{\detokenize{Manual:figure-7-5}}\end{figure}


\section{CSEM example}
\label{\detokenize{Manual:csem-example}}\label{\detokenize{Manual:examples}}
This section includes a step-by-step walk-through of the process to solve a
simple 3D CSEM survey. The typical process to solve a problem using
PETGEM is followed: a model is meshed, PETGEM input files are preprocessed and modeled by
using \sphinxcode{\sphinxupquote{kernel.py}} script to solve
the modelling and finally the results of the simulation are visualised.

All necessary data to reproduce the following examples are available in the
{\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}} section.


\subsection{Example 1: Canonical model of an off-shore hydrocarbon reservoir}
\label{\detokenize{Manual:example-1-canonical-model-of-an-off-shore-hydrocarbon-reservoir}}

\subsubsection{Model}
\label{\detokenize{Manual:model}}
In order to explain the 3D CSEM modelling using PETGEM, here is considered the
canonical model by
\sphinxhref{http://marineemlab.ucsd.edu/steve/bio/ThinResistors.pdf}{Weiss2006} which
consists in four-layers: 1000 m thick seawater (3.3 \(S/m\)), 1000 m thick sediments
(1 \(S/m\)), 100 m thick oil (0.01 \(S/m\)) and 1400 m thick sediments
(1 \(S/m\)). The computational domain is a \([0,3500]^3\) m cube. For this model,
a 2 Hz x-directed dipole source is located at \(z=975\), \(x=1750\),
\(y=1750\). The receivers are placed in-line to the source position and along its
orientation, directly above the seafloor (\(z = 990\)). Further, the
Nédélec element order is p=1 (first order)


\subsubsection{Meshing}
\label{\detokenize{Manual:meshing}}
PETGEM V1.0 is based on tetrahedral meshes. Therefore,  {\hyperref[\detokenize{Manual:figure-7-8}]{\sphinxcrossref{Figure 7.8}}}
shows a 3D view of the model with its unstructured tetrahedral mesh for
the halfspace \(y>1750\), with the color scale representing the electrical
conductivity \(\sigma\) for each layer. Mesh in {\hyperref[\detokenize{Manual:figure-7-8}]{\sphinxcrossref{Figure 7.8}}} have been
obtained using \sphinxhref{http://gmsh.info/}{Gmsh}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.35]{{model1}.png}
\caption{Figure 7.8. In-line canonical off-shore hydrocarbon model with its unstructured tetrahedral mesh for \(y>1750\). The color scale represents the electrical conductivity \(\sigma\) for each layer.}\label{\detokenize{Manual:id21}}\label{\detokenize{Manual:figure-7-8}}\end{figure}

In this case, the mesh is composed by four conductivity materials. Please, see
\sphinxhref{http://gmsh.info/}{Gmsh} manual for details about the mesh creation process.


\subsubsection{Parameters file for PETGEM}
\label{\detokenize{Manual:parameters-file-for-petgem}}
The parameters file used for this example follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} PETGEM parameters file}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Model parameters}
\PYG{n}{model}\PYG{p}{:}
  \PYG{n}{mode}\PYG{p}{:} \PYG{n}{csem}    \PYG{c+c1}{\PYGZsh{} Modeling mode: csem or mt}
  \PYG{n}{csem}\PYG{p}{:}
    \PYG{n}{sigma}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{}file: \PYGZsq{}my\PYGZus{}file.h5\PYGZsq{}                \PYGZsh{} Conductivity model file}
      \PYG{n}{horizontal}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{3.3333}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Horizontal conductivity}
      \PYG{n}{vertical}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{3.3333}\PYG{p}{]}    \PYG{c+c1}{\PYGZsh{} Vertical conductivity}
    \PYG{n}{source}\PYG{p}{:}
      \PYG{n}{frequency}\PYG{p}{:} \PYG{l+m+mf}{2.}                     \PYG{c+c1}{\PYGZsh{} Frequency (Hz)}
      \PYG{n}{position}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1750.}\PYG{p}{,} \PYG{l+m+mf}{1750.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{975.}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} Source position (xyz)}
      \PYG{n}{azimuth}\PYG{p}{:} \PYG{l+m+mf}{0.}                       \PYG{c+c1}{\PYGZsh{} Source rotation in xy plane (in degrees)}
      \PYG{n}{dip}\PYG{p}{:} \PYG{l+m+mf}{0.}                           \PYG{c+c1}{\PYGZsh{} Source rotation in xz plane (in degrees)}
      \PYG{n}{current}\PYG{p}{:} \PYG{l+m+mf}{1.}                       \PYG{c+c1}{\PYGZsh{} Source current (Am)}
      \PYG{n}{length}\PYG{p}{:} \PYG{l+m+mf}{1.}                        \PYG{c+c1}{\PYGZsh{} Source length  (m)}

  \PYG{c+c1}{\PYGZsh{} Common parameters for all models}
  \PYG{n}{mesh}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}1}\PYG{o}{/}\PYG{n}{DIPOLE1D}\PYG{o}{.}\PYG{n}{msh}   \PYG{c+c1}{\PYGZsh{} Mesh file (gmsh format v2)}
  \PYG{n}{receivers}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}1}\PYG{o}{/}\PYG{n}{receiver\PYGZus{}pos}\PYG{o}{.}\PYG{n}{h5} \PYG{c+c1}{\PYGZsh{} Receiver positions file (xyz)}

\PYG{c+c1}{\PYGZsh{} Execution parameters}
\PYG{n}{run}\PYG{p}{:}
  \PYG{n}{nord}\PYG{p}{:} \PYG{l+m+mi}{1}       \PYG{c+c1}{\PYGZsh{} Vector basis order (1,2,3,4,5,6)}
  \PYG{n}{cuda}\PYG{p}{:} \PYG{k+kc}{False}   \PYG{c+c1}{\PYGZsh{} Cuda support (True or False)}

\PYG{c+c1}{\PYGZsh{} Output parameters}
\PYG{n}{output}\PYG{p}{:}
  \PYG{n}{vtk}\PYG{p}{:} \PYG{k+kc}{True}                               \PYG{c+c1}{\PYGZsh{} Postprocess vtk file (EM fields, conductivity)}
  \PYG{n}{directory}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}1}\PYG{o}{/}\PYG{n}{out}           \PYG{c+c1}{\PYGZsh{} Directory for output (results)}
  \PYG{n}{directory\PYGZus{}scratch}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}1}\PYG{o}{/}\PYG{n}{tmp}   \PYG{c+c1}{\PYGZsh{} Directory for temporal files}
\end{sphinxVerbatim}

Note that you may wish to change the location of the input files to
somewhere on your drive. The solver options have been configured in the \sphinxcode{\sphinxupquote{petsc.opts}} file as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}type} \PYG{n}{gmres}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{sor}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}rtol} \PYG{l+m+mf}{1e\PYGZhy{}8}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}converged\PYGZus{}reason}
\PYG{o}{\PYGZhy{}}\PYG{n}{log\PYGZus{}summary}
\end{sphinxVerbatim}

That’s it, we are now ready to solve the modelling.


\subsubsection{Running PETGEM}
\label{\detokenize{Manual:running-petgem}}
To run the simulation, the following command should be run in the top-level
directory of the PETGEM source tree:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mpirun \PYGZhy{}n \PYG{l+m}{16} python3 kernel.py \PYGZhy{}options\PYGZus{}file case1/petsc.opts case1/params.yaml
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{kernel.py}} solves the problem as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Problem initialization

\item {} 
Preprocessing data

\item {} 
Import files

\item {} 
Parallel assembly system

\item {} 
Parallel solution system

\item {} 
Post-processing of electric responses

\end{enumerate}

and outputs the solution to the output path
(\sphinxcode{\sphinxupquote{case1/out/}}). The output file will be in hdf5 format.


\subsubsection{PETGEM post-processing}
\label{\detokenize{Manual:petgem-post-processing}}
Once a solution of a 3D CSEM survey has been obtained, it should be
post-processed by using a visualization program. PETGEM does not do the
visualization by itself, but it generates output file (hdf5)
with the electric responses and receivers positions. It also gives timing values
in order to evaluate the performance.

The electric fields responses can be handled freely and plotted. The
dimension of the array is determined by the
number of receivers in the modelling (58 in this example). {\hyperref[\detokenize{Manual:figure-7-9}]{\sphinxcrossref{Figure 7.9}}} shows
a comparison of the x-component of total electric field between PETGEM results
and the quasi-analytical solution obtained with the
\sphinxhref{http://marineemlab.ucsd.edu/~kkey/pubs/2009b.pdf}{DIPOLE1D} tool. The total
electric field in {\hyperref[\detokenize{Manual:figure-7-9}]{\sphinxcrossref{Figure 7.9}}} was calculated using a
mesh with \(\approx2\) millions of DOFs.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{total_field_X_model1}.png}
\caption{Figure 7.9. Total electric field comparative for x-component between PETGEM V1.0 and DIPOLE1D.}\label{\detokenize{Manual:id22}}\label{\detokenize{Manual:figure-7-9}}\end{figure}


\subsection{Example 2: Use of high-order Nédélec elements}
\label{\detokenize{Manual:example-2-use-of-high-order-nedelec-elements}}
In order to show the potential of high-order Nédélec elements, here is
considered the same model of previous example. In this case, the
Nédélec element order is p=2 (second order).


\subsubsection{Meshing}
\label{\detokenize{Manual:id8}}
As in previous example, the mesh is composed by four conductivity materials. The
resulting \sphinxhref{http://gmsh.info/}{Gmsh} script can be found in {\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}}
section. It is worth to mention that the use a Nédélec element order p=2 helps
to reduce the number of tetrahedral elements to achieved a certain error level.


\subsubsection{Parameters file for PETGEM}
\label{\detokenize{Manual:id9}}
The parameters file used for this example follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} PETGEM parameters file}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Model parameters}
\PYG{n}{model}\PYG{p}{:}
  \PYG{n}{mode}\PYG{p}{:} \PYG{n}{csem}    \PYG{c+c1}{\PYGZsh{} Modeling mode: csem or mt}
  \PYG{n}{csem}\PYG{p}{:}
    \PYG{n}{sigma}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{}file: \PYGZsq{}my\PYGZus{}file.h5\PYGZsq{}                \PYGZsh{} Conductivity model file}
      \PYG{n}{horizontal}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{3.3333}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Horizontal conductivity}
      \PYG{n}{vertical}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{3.3333}\PYG{p}{]}    \PYG{c+c1}{\PYGZsh{} Vertical conductivity}
    \PYG{n}{source}\PYG{p}{:}
      \PYG{n}{frequency}\PYG{p}{:} \PYG{l+m+mf}{2.}                     \PYG{c+c1}{\PYGZsh{} Frequency (Hz)}
      \PYG{n}{position}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1750.}\PYG{p}{,} \PYG{l+m+mf}{1750.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{975.}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} Source position (xyz)}
      \PYG{n}{azimuth}\PYG{p}{:} \PYG{l+m+mf}{0.}                       \PYG{c+c1}{\PYGZsh{} Source rotation in xy plane (in degrees)}
      \PYG{n}{dip}\PYG{p}{:} \PYG{l+m+mf}{0.}                           \PYG{c+c1}{\PYGZsh{} Source rotation in xz plane (in degrees)}
      \PYG{n}{current}\PYG{p}{:} \PYG{l+m+mf}{1.}                       \PYG{c+c1}{\PYGZsh{} Source current (Am)}
      \PYG{n}{length}\PYG{p}{:} \PYG{l+m+mf}{1.}                        \PYG{c+c1}{\PYGZsh{} Source length  (m)}
  \PYG{n}{mt}\PYG{p}{:}
    \PYG{n}{sigma}\PYG{p}{:}
      \PYG{n}{file}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}file.h5}\PYG{l+s+s1}{\PYGZsq{}}                \PYG{c+c1}{\PYGZsh{} Conductivity model file}
      \PYG{c+c1}{\PYGZsh{}horizontal: [1.e\PYGZhy{}10, 0.01]       \PYGZsh{} Horizontal conductivity}
      \PYG{c+c1}{\PYGZsh{}vertical: [1.e\PYGZhy{}10, 0.01]         \PYGZsh{} Vertical conductivity}
    \PYG{n}{frequency}\PYG{p}{:} \PYG{l+m+mf}{4.}                      \PYG{c+c1}{\PYGZsh{} Frequency (Hz)}
    \PYG{n}{polarization}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}                 \PYG{c+c1}{\PYGZsh{} Polarization mode for mt (xyz)}

  \PYG{c+c1}{\PYGZsh{} Common parameters for all models}
  \PYG{n}{mesh}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}2}\PYG{o}{/}\PYG{n}{DIPOLE1D}\PYG{o}{.}\PYG{n}{msh}   \PYG{c+c1}{\PYGZsh{} Mesh file (gmsh format v2)}
  \PYG{n}{receivers}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}2}\PYG{o}{/}\PYG{n}{receiver\PYGZus{}pos}\PYG{o}{.}\PYG{n}{h5} \PYG{c+c1}{\PYGZsh{} Receiver positions file (xyz)}

\PYG{c+c1}{\PYGZsh{} Execution parameters}
\PYG{n}{run}\PYG{p}{:}
  \PYG{n}{nord}\PYG{p}{:} \PYG{l+m+mi}{2}       \PYG{c+c1}{\PYGZsh{} Vector basis order (1,2,3,4,5,6)}
  \PYG{n}{cuda}\PYG{p}{:} \PYG{k+kc}{False}   \PYG{c+c1}{\PYGZsh{} Cuda support (True or False)}

\PYG{c+c1}{\PYGZsh{} Output parameters}
\PYG{n}{output}\PYG{p}{:}
  \PYG{n}{vtk}\PYG{p}{:} \PYG{k+kc}{True}                               \PYG{c+c1}{\PYGZsh{} Postprocess vtk file (EM fields, conductivity)}
  \PYG{n}{directory}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}2}\PYG{o}{/}\PYG{n}{out}           \PYG{c+c1}{\PYGZsh{} Directory for output (results)}
  \PYG{n}{directory\PYGZus{}scratch}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}2}\PYG{o}{/}\PYG{n}{tmp}   \PYG{c+c1}{\PYGZsh{} Directory for temporal files}
\end{sphinxVerbatim}


\subsubsection{Running PETGEM}
\label{\detokenize{Manual:id10}}
To run the simulation, the following command should be run in the top-level
directory of the PETGEM source tree:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mpirun \PYGZhy{}n \PYG{l+m}{48} python3 kernel.py \PYGZhy{}options\PYGZus{}file case2/petsc.opts case2/params.yaml
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{kernel.py}} solves the problem as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Problem initialization

\item {} 
Preprocessing data

\item {} 
Import files

\item {} 
Parallel assembly system

\item {} 
Parallel solution system

\item {} 
Post-processing of electric responses

\end{enumerate}

and outputs the solution to the output path
(\sphinxcode{\sphinxupquote{case2/out}}). The output files will be in hdf5 format.


\subsubsection{Nédélec order comparison}
\label{\detokenize{Manual:nedelec-order-comparison}}
{\hyperref[\detokenize{Manual:figure-7-10}]{\sphinxcrossref{Figure 7.10}}} shows a comparison of the x-component of total electric field between p=1
and p=2 against the quasi-analytical solution obtained with the
\sphinxhref{http://marineemlab.ucsd.edu/~kkey/pubs/2009b.pdf}{DIPOLE1D} tool. The total
electric field in {\hyperref[\detokenize{Manual:figure-7-10}]{\sphinxcrossref{Figure 7.10}}} was calculated using a
mesh with \(\approx2\) millions of DOFs for p=1 and a mesh with
\(\approx600\) thousands of DOFs.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.4]{{total_field_X_model2}.png}
\caption{Figure 7.10. Nédélec order comparative within PETGEM V1.0}\label{\detokenize{Manual:id23}}\label{\detokenize{Manual:figure-7-10}}\end{figure}


\subsection{Example 3: Use of PETSc solvers}
\label{\detokenize{Manual:example-3-use-of-petsc-solvers}}
In PETGEM, options for \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} solvers/preconditioners
are accessible via the \sphinxcode{\sphinxupquote{petsc.opts}} file. Here is presented a short list of
relevant configuration options for the solution of the problem under
consideration.
\begin{itemize}
\item {} 
Direct solver by \sphinxhref{http://mumps.enseeiht.fr/}{MUMPs} via \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} interface

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for PETSc}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{lu}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}factor\PYGZus{}mat\PYGZus{}solver\PYGZus{}package} \PYG{n}{mumps}
\end{sphinxVerbatim}

\item {} 
Generalized minimal residual (GMRES) solver with a successive over-relaxation method (SOR) as preconditioner. Further, these options prints useful information: True residual norm, the preconditioned residual norm at each iteration and reason a iterative method was said to have converged or diverged.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for PETSc}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}type} \PYG{n}{gmres}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{sor}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}rtol} \PYG{l+m+mf}{1e\PYGZhy{}8}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}monitor\PYGZus{}true\PYGZus{}residual}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}converged\PYGZus{}reason}
\end{sphinxVerbatim}

\item {} 
Generalized minimal residual (GMRES) solver with a geometric algebraic multigrid method (GAMG) as preconditioner.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for PETSc}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}type} \PYG{n}{gmres}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{gamg}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}rtol} \PYG{l+m+mf}{1e\PYGZhy{}8}
\end{sphinxVerbatim}

\item {} 
Generalized minimal residual (GMRES) solver with an additive Schwarz method (ASM) as preconditioner.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for PETSc}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}type} \PYG{n}{gmres}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{asm}
\PYG{o}{\PYGZhy{}}\PYG{n}{sub\PYGZus{}pc\PYGZus{}type} \PYG{n}{lu}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}rtol} \PYG{l+m+mf}{1e\PYGZhy{}8}
\end{sphinxVerbatim}

\item {} 
Generalized minimal residual (GMRES) solver with a Jacobi method as preconditioner.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for PETSc}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}type} \PYG{n}{gmres}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{bjacobi}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}rtol} \PYG{l+m+mf}{1e\PYGZhy{}8}
\end{sphinxVerbatim}

\item {} 
Transpose free quasi-minimal residual (TFQMR) solver with a successive over-relaxation method (SOR) as preconditioner.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for PETSc}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}type} \PYG{n}{tfqmr}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{sor}
\PYG{o}{\PYGZhy{}}\PYG{n}{ksp\PYGZus{}rtol} \PYG{l+m+mf}{1e\PYGZhy{}8}
\end{sphinxVerbatim}

\end{itemize}

Previous configuration are based on most used in the literature.


\section{MT example}
\label{\detokenize{Manual:mt-example}}
This section includes a step-by-step walk-through of the process to solve a
simple 3D MT survey. The typical process to solve a problem using
PETGEM is followed: a model is meshed, PETGEM input files are preprocessed and modeled by
using \sphinxcode{\sphinxupquote{kernel.py}} script to solve
the modelling and finally the results of the simulation are visualised.

All necessary data to reproduce the following examples are available in the
{\hyperref[\detokenize{Download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{Download}}}} section.


\subsection{Example 4: 3D trapezoidal hill model}
\label{\detokenize{Manual:example-4-3d-trapezoidal-hill-model}}

\subsubsection{Model}
\label{\detokenize{Manual:id12}}
In order to explain the 3D MT modelling using PETGEM, here is considered a 3D
trapezoidal hill model. This test case is a homogeneous half-space model with
1/100 \(S/m\) as host resistivity and 1e-9 \(S/m\) as the free-space
resistivity. The trapezoidal hill, centered at the computational domain, has a
height of 0.45km with a hill-top square of 0.45km X 0.45km,
and a hill-bottom square of 2km X 2km. A cross-section view of
the model under consideration is depicted in {\hyperref[\detokenize{Manual:figure-7-11}]{\sphinxcrossref{Figure 7.11}}}. By using the
horizontal components of the EM fields at 2Hz, the apparent resistivities are
computed. 41 sites at 0km and along the x-axis are arranged equidistant
spacing over the interval x={[}-2:2{]}km. Further, the Nédélec element order
is p=2 (second order).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.35]{{model2}.png}
\caption{Figure 7.11. Cross-section view of the 3D trapezoidal hill model (left-panel) with its resulting computational unstructured and hp-adapted mesh for p = 2 (right-panel).}\label{\detokenize{Manual:id24}}\label{\detokenize{Manual:figure-7-11}}\end{figure}


\subsubsection{Parameters file for PETGEM}
\label{\detokenize{Manual:id13}}
The parameters file used for this example follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} PETGEM parameters file}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Model parameters}
\PYG{n}{model}\PYG{p}{:}
  \PYG{n}{mode}\PYG{p}{:} \PYG{n}{mt}    \PYG{c+c1}{\PYGZsh{} Modeling mode: csem or mt}
  \PYG{n}{mt}\PYG{p}{:}
    \PYG{n}{sigma}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{}file: \PYGZsq{}my\PYGZus{}file.h5\PYGZsq{}                \PYGZsh{} Conductivity model file}
      \PYG{n}{horizontal}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}       \PYG{c+c1}{\PYGZsh{} Horizontal conductivity}
      \PYG{n}{vertical}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}         \PYG{c+c1}{\PYGZsh{} Vertical conductivity}
    \PYG{n}{frequency}\PYG{p}{:} \PYG{l+m+mf}{2.}                      \PYG{c+c1}{\PYGZsh{} Frequency (Hz)}
    \PYG{n}{polarization}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xy}\PYG{l+s+s1}{\PYGZsq{}}                 \PYG{c+c1}{\PYGZsh{} Polarization mode for mt (xyz)}

  \PYG{c+c1}{\PYGZsh{} Common parameters for all models}
  \PYG{n}{mesh}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}4}\PYG{o}{/}\PYG{n}{mesh\PYGZus{}trapezoidal}\PYG{o}{.}\PYG{n}{msh}   \PYG{c+c1}{\PYGZsh{} Mesh file (gmsh format v2)}
  \PYG{n}{receivers}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}4}\PYG{o}{/}\PYG{n}{receivers}\PYG{o}{.}\PYG{n}{h5} \PYG{c+c1}{\PYGZsh{} Receiver positions file (xyz)}

\PYG{c+c1}{\PYGZsh{} Execution parameters}
\PYG{n}{run}\PYG{p}{:}
  \PYG{n}{nord}\PYG{p}{:} \PYG{l+m+mi}{2}       \PYG{c+c1}{\PYGZsh{} Vector basis order (1,2,3,4,5,6)}
  \PYG{n}{cuda}\PYG{p}{:} \PYG{k+kc}{False}   \PYG{c+c1}{\PYGZsh{} Cuda support (True or False)}

\PYG{c+c1}{\PYGZsh{} Output parameters}
\PYG{n}{output}\PYG{p}{:}
  \PYG{n}{vtk}\PYG{p}{:} \PYG{k+kc}{False}                               \PYG{c+c1}{\PYGZsh{} Postprocess vtk file (EM fields, conductivity)}
  \PYG{n}{directory}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}4}\PYG{o}{/}\PYG{n}{out}           \PYG{c+c1}{\PYGZsh{} Directory for output (results)}
  \PYG{n}{directory\PYGZus{}scratch}\PYG{p}{:} \PYG{n}{examples}\PYG{o}{/}\PYG{n}{case\PYGZus{}4}\PYG{o}{/}\PYG{n}{tmp}   \PYG{c+c1}{\PYGZsh{} Directory for temporal files}
\end{sphinxVerbatim}

Note that you may wish to change the location of the input files to
somewhere on your drive. The solver options have been configured in the \sphinxcode{\sphinxupquote{petsc.opts}} file as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solver options for}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}type} \PYG{n}{lu}
\PYG{o}{\PYGZhy{}}\PYG{n}{pc\PYGZus{}factor\PYGZus{}mat\PYGZus{}solver\PYGZus{}package} \PYG{n}{mumps}
\end{sphinxVerbatim}

That’s it, we are now ready to solve the modelling.


\subsubsection{Running PETGEM}
\label{\detokenize{Manual:id14}}
To run the simulation, the following command should be run in the top-level
directory of the PETGEM source tree:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mpirun \PYGZhy{}n \PYG{l+m}{16} python3 kernel.py \PYGZhy{}options\PYGZus{}file case4/petsc.opts case4/params.yaml
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{kernel.py}} solves the problem as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Problem initialization

\item {} 
Preprocessing data

\item {} 
Import files

\item {} 
Parallel assembly system (twice, 1 for each polarization mode)

\item {} 
Parallel solution system (twice, 1 for each polarization mode)

\item {} 
Post-processing of electric responses, apparent resistivities and phases

\end{enumerate}

and outputs the solution to the output path
(\sphinxcode{\sphinxupquote{case4/out/}}). The output file will be in hdf5 format.


\subsubsection{PETGEM post-processing}
\label{\detokenize{Manual:id15}}
Once a solution of a 3D MT survey has been obtained, it should be
post-processed by using a visualization program. PETGEM does not do the
visualization by itself, but it generates output file (hdf5)
with the electric responses (apparent resistivities and phases) and
receivers positions. It also gives timing values in order to evaluate the
performance.

The electric fields responses can be handled freely and plotted. The
dimension of the array is determined by the
number of receivers in the modelling (41 in this example). {\hyperref[\detokenize{Manual:figure-7-12}]{\sphinxcrossref{Figure 7.12}}} shows
a comparison of the obtained apparent resistivity and phase.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{apparent_resistivity_phase}.png}
\caption{Figure 7.12. Apparent resistivities (left-panel) and phases (right-panel) for the 3D trapezoidal hill model. The PETGEM solutions were calculated with p = 2.}\label{\detokenize{Manual:id25}}\label{\detokenize{Manual:figure-7-12}}\end{figure}


\section{Code documentation}
\label{\detokenize{Manual:code-documentation}}\label{\detokenize{Manual:id16}}
Following sub-sections are dedicated to code documentation of PETGEM.


\subsection{kernel}
\label{\detokenize{Manual:kernel}}

\subsubsection{kernel.py}
\label{\detokenize{petgem/kernel:module-kernel}}\label{\detokenize{petgem/kernel:kernel-py}}\label{\detokenize{petgem/kernel::doc}}\index{kernel (module)@\spxentry{kernel}\spxextra{module}}
\sphinxstylestrong{PETGEM} kernel for 3D CSEM/MT forward modelling using high order vector elements.


\subsection{Common scripts}
\label{\detokenize{Manual:common-scripts}}

\subsubsection{common.py}
\label{\detokenize{petgem/common:module-petgem.common}}\label{\detokenize{petgem/common:common-py}}\label{\detokenize{petgem/common::doc}}\index{petgem.common (module)@\spxentry{petgem.common}\spxextra{module}}
Define common operations for \sphinxstylestrong{PETGEM}.
\index{InputParameters (class in petgem.common)@\spxentry{InputParameters}\spxextra{class in petgem.common}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.InputParameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{petgem.common.}}\sphinxbfcode{\sphinxupquote{InputParameters}}}{\emph{params}, \emph{parEnv}}{}
Method to import a yaml parameter file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{object}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} user params yaml file.

\item[{Returns}] \leavevmode
user parameters as object view.

\item[{Return type}] \leavevmode
object.

\end{description}\end{quote}

\end{fulllineitems}

\index{Print (class in petgem.common)@\spxentry{Print}\spxextra{class in petgem.common}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.Print}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{petgem.common.}}\sphinxbfcode{\sphinxupquote{Print}}}{\emph{text}, \emph{color\_code=None}}{}
This class provides methods for pretty print.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{str}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} string to be printed.

\item[{Returns}] \leavevmode
None.

\item[{Return type}] \leavevmode
None.

\end{description}\end{quote}
\index{header() (petgem.common.Print class method)@\spxentry{header()}\spxextra{petgem.common.Print class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.Print.header}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{header}}}{}{}
Print the header.
\begin{quote}\begin{description}
\item[{Param}] \leavevmode
None.

\item[{Returns}] \leavevmode
None.

\item[{Return type}] \leavevmode
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{master() (petgem.common.Print class method)@\spxentry{master()}\spxextra{petgem.common.Print class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.Print.master}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{master}}}{\emph{text}, \emph{color\_code=None}}{}
If the caller is the master process, this method prints a message.
\begin{quote}\begin{description}
\item[{Param}] \leavevmode
None.

\item[{Returns}] \leavevmode
None.

\item[{Return type}] \leavevmode
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Timer (class in petgem.common)@\spxentry{Timer}\spxextra{class in petgem.common}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.Timer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{petgem.common.}}\sphinxbfcode{\sphinxupquote{Timer}}}{\emph{elapsed=0}}{}
Definition of timer class.
\index{elapsed (petgem.common.Timer attribute)@\spxentry{elapsed}\spxextra{petgem.common.Timer attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.Timer.elapsed}}\pysigline{\sphinxbfcode{\sphinxupquote{elapsed}}\sphinxbfcode{\sphinxupquote{ = None}}}
\end{fulllineitems}

\index{reset() (petgem.common.Timer method)@\spxentry{reset()}\spxextra{petgem.common.Timer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.Timer.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Reset timer.

\end{fulllineitems}

\index{start() (petgem.common.Timer method)@\spxentry{start()}\spxextra{petgem.common.Timer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.Timer.start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{start}}}{}{}
Start timer.

\end{fulllineitems}

\index{stop() (petgem.common.Timer method)@\spxentry{stop()}\spxextra{petgem.common.Timer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.Timer.stop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stop}}}{}{}
Stop timer.

\end{fulllineitems}


\end{fulllineitems}

\index{measure\_all\_class\_methods() (in module petgem.common)@\spxentry{measure\_all\_class\_methods()}\spxextra{in module petgem.common}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.measure_all_class_methods}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.common.}}\sphinxbfcode{\sphinxupquote{measure\_all\_class\_methods}}}{\emph{Cls}}{}
“Implement a decorator to measure execution time for each method.
\begin{description}
\item[{Args:}] \leavevmode
f: the decorated function

\item[{Returns:}] \leavevmode
a function wrap

\end{description}

\end{fulllineitems}

\index{measure\_time() (in module petgem.common)@\spxentry{measure\_time()}\spxextra{in module petgem.common}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.measure_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.common.}}\sphinxbfcode{\sphinxupquote{measure\_time}}}{\emph{f=None}, \emph{group=None}, \emph{split=False}}{}
“Implement method to measure execution time.
\begin{description}
\item[{Args:}] \leavevmode
f: the decorated function
group: the group name
split: decides if all blocks in a group contribute to the same timer

\item[{Returns:}] \leavevmode
a function wrap

\end{description}

\end{fulllineitems}

\index{unitary\_test() (in module petgem.common)@\spxentry{unitary\_test()}\spxextra{in module petgem.common}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/common:petgem.common.unitary_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.common.}}\sphinxbfcode{\sphinxupquote{unitary\_test}}}{}{}
Unitary test for common.py script.

\end{fulllineitems}



\subsection{Pre-processing}
\label{\detokenize{Manual:pre-processing}}

\subsubsection{preprocessing.py}
\label{\detokenize{petgem/preprocessing:module-petgem.preprocessing}}\label{\detokenize{petgem/preprocessing:preprocessing-py}}\label{\detokenize{petgem/preprocessing::doc}}\index{petgem.preprocessing (module)@\spxentry{petgem.preprocessing}\spxextra{module}}
Define data preprocessing operations for \sphinxstylestrong{PETGEM}.
\index{unitary\_test() (in module petgem.preprocessing)@\spxentry{unitary\_test()}\spxextra{in module petgem.preprocessing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/preprocessing:petgem.preprocessing.unitary_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.preprocessing.}}\sphinxbfcode{\sphinxupquote{unitary\_test}}}{}{}
Unitary test for preprocessing.py script.

\end{fulllineitems}



\subsection{Mesh scripts}
\label{\detokenize{Manual:mesh-scripts}}

\subsubsection{mesh.py}
\label{\detokenize{petgem/mesh:module-petgem.mesh}}\label{\detokenize{petgem/mesh:mesh-py}}\label{\detokenize{petgem/mesh::doc}}\index{petgem.mesh (module)@\spxentry{petgem.mesh}\spxextra{module}}
Define functions for mesh handling.
\index{computeBoundaries() (in module petgem.mesh)@\spxentry{computeBoundaries()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.computeBoundaries}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{computeBoundaries}}}{\emph{dof\_connectivity}, \emph{dof\_edges}, \emph{dof\_faces}, \emph{bEdges}, \emph{bFaces}, \emph{Nord}}{}
Compute the indexes of dofs boundaries and internal dofs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dof\_connectivity}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} local/global dofs list for elements

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dof\_edges}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} dofs index on edges

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dof\_faces}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} dofs index on faces

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bEdges}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} boundary-edges connectivity with dimensions = (number\_boundary\_edges,1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bfaces}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} indexes of boundary-faces = (number\_boundary\_faces, 1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order of nedelec basis functions

\end{itemize}

\item[{Returns}] \leavevmode
indexes of internal dofs and indexes of boundary dofs

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeBoundaryEdges() (in module petgem.mesh)@\spxentry{computeBoundaryEdges()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.computeBoundaryEdges}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{computeBoundaryEdges}}}{\emph{edgesN}, \emph{bfacesN}}{}
Compute boundary edges of a tetrahedral mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{edgesN}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} edges-nodes connectivity.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bfacesN}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} boundary-faces-nodes connectivity.

\end{itemize}

\item[{Returns}] \leavevmode
boundary-edges connectivity.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeBoundaryElements() (in module petgem.mesh)@\spxentry{computeBoundaryElements()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.computeBoundaryElements}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{computeBoundaryElements}}}{\emph{elemsF}, \emph{bFaces}, \emph{nFaces}}{}
Compute boundary elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsF}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-faces connectivity.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bfaces}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} indexes of boundary faces.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nFaces}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of faces in the mesh.

\end{itemize}

\item[{Returns}] \leavevmode
indexes of boundary elements.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeBoundaryFaces() (in module petgem.mesh)@\spxentry{computeBoundaryFaces()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.computeBoundaryFaces}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{computeBoundaryFaces}}}{\emph{elemsF}, \emph{facesN}}{}
Compute boundary faces of a tetrahedral mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsF}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-face connectivity.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{facesN}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} faces-nodes connectivity.

\end{itemize}

\item[{Returns}] \leavevmode
nodal-connectivity and indexes of boundary-faces, number of boundary faces.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeEdges() (in module petgem.mesh)@\spxentry{computeEdges()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.computeEdges}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{computeEdges}}}{\emph{elemsN}, \emph{nElems}}{}
Compute edges of a 3D tetrahedral mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsN}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-nodes connectivity.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nElems}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of tetrahedral elements in the mesh.

\end{itemize}

\item[{Returns}] \leavevmode
edges connectivity and edgesNodes connectivity.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeFacePlane() (in module petgem.mesh)@\spxentry{computeFacePlane()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.computeFacePlane}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{computeFacePlane}}}{\emph{nodes}, \emph{bFaces}, \emph{bFacesN}}{}
Compute the plane id to which the boundary belongs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} nodes coordinates.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bFaces}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} indexes of boundary-faces.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bFacesN}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} boundary-faces-nodes connectivity.

\end{itemize}

\item[{Returns}] \leavevmode
plane id to which the boundary belongs.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeFaces() (in module petgem.mesh)@\spxentry{computeFaces()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.computeFaces}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{computeFaces}}}{\emph{elemsN}, \emph{nElems}}{}
Compute the element’s faces of a 3D tetrahedral mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{matrix}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-faces connectivity.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nElems}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of elements in the mesh.

\end{itemize}

\item[{Returns}] \leavevmode
element/faces connectivity.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
References:n
Rognes, Marie E., Robert Cndarray. Kirby, and Anders Logg. “Efficient
assembly of H(div) and H(curl) conforming finite elements.”
SIAM Journal on Scientific Computing 31.6 (2009): 4130-4151.
\end{sphinxadmonition}

\end{fulllineitems}

\index{computeFacesEdges() (in module petgem.mesh)@\spxentry{computeFacesEdges()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.computeFacesEdges}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{computeFacesEdges}}}{\emph{elemsF}, \emph{elemsE}, \emph{nFaces}, \emph{nElems}}{}
Compute the edge’s faces connectivity
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsF}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-faces connectivity.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsE}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-edges connectivity.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nFaces}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of faces in the mesh.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nElems}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of elements in the mesh.

\end{itemize}

\item[{Returns}] \leavevmode
edges/faces connectivity.

\item[{Return type}] \leavevmode
ndarray.

\end{description}\end{quote}

\end{fulllineitems}

\index{unitary\_test() (in module petgem.mesh)@\spxentry{unitary\_test()}\spxextra{in module petgem.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/mesh:petgem.mesh.unitary_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.mesh.}}\sphinxbfcode{\sphinxupquote{unitary\_test}}}{}{}
Unitary test for mesh.py script.

\end{fulllineitems}



\subsection{HEFEM scripts}
\label{\detokenize{Manual:hefem-scripts}}

\subsubsection{hvfem.py}
\label{\detokenize{petgem/hvfem:module-petgem.hvfem}}\label{\detokenize{petgem/hvfem:hvfem-py}}\label{\detokenize{petgem/hvfem::doc}}\index{petgem.hvfem (module)@\spxentry{petgem.hvfem}\spxextra{module}}
Define functions for high-order vector finite element method.
\index{AffineTetrahedron() (in module petgem.hvfem)@\spxentry{AffineTetrahedron()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.AffineTetrahedron}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{AffineTetrahedron}}}{\emph{X}}{}
Compute affine coordinates and their gradients.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{X}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} point coordinates

\item[{Returns}] \leavevmode
affine coordinates and gradients of affine coordinates

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
References:n
Fuentes, F., Keith, B., Demkowicz, L., \& Nagaraj, S. (2015). Orientation
embedded high order shape functions for the exact sequence elements of
all shapes. Computers \& Mathematics with applications, 70(4), 353-458.
\end{sphinxadmonition}

\end{fulllineitems}

\index{AncEE() (in module petgem.hvfem)@\spxentry{AncEE()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.AncEE}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{AncEE}}}{\emph{S}, \emph{DS}, \emph{Nord}, \emph{Idec}, \emph{N}}{}
Compute edge Hcurl ancillary functions and their curls.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{S}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} affine coordinates associated to edge

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{DS}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} derivatives of S in R\textasciicircum{}N

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Idec}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Binary flag

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{N}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} spatial dimension

\end{itemize}

\item[{Returns}] \leavevmode
edge Hcurl ancillary functions, curls of edge Hcurl ancillary functions

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
References:n
Idec: = FALSE  s0+s1 != 1
\begin{quote}

= TRUE   s0+s1  = 1
\end{quote}
\end{sphinxadmonition}

\end{fulllineitems}

\index{AncETri() (in module petgem.hvfem)@\spxentry{AncETri()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.AncETri}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{AncETri}}}{\emph{S}, \emph{DS}, \emph{Nord}, \emph{Idec}, \emph{N}}{}
Compute triangle face Hcurl ancillary functions and their curls.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{S}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} (s0,s1,s2) affine coordinates associated to triangle face

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{DS}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} derivatives of S0,S1,S2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Idec}} (\sphinxstyleliteralemphasis{\sphinxupquote{boll}}) \textendash{} Binary flag:

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{N}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} spatial dimension

\end{itemize}

\item[{Returns}] \leavevmode
triangle Hcurl ancillary functions and curls of triangle Hcurl ancillary functions

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{HomIJacobi() (in module petgem.hvfem)@\spxentry{HomIJacobi()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.HomIJacobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{HomIJacobi}}}{\emph{S}, \emph{DS}, \emph{Nord}, \emph{Minalpha}, \emph{Idec}, \emph{N}}{}
Compute values of integrated homogenized Jacobi polynomials and their gradients.
Result is half of a  matrix with each row  associated to a fixed alpha.
Alpha grows by 2 in each row.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{S}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} (s0,s1) affine(like) coordinates

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{DS}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} gradients of S in R(N)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} max polynomial order

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Minalpha}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} first row value of alpha (integer)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Idec}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} decision flag to compute

\end{itemize}

\item[{Returns}] \leavevmode
polynomial values and derivatives in x (Jacobi polynomials)

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{HomLegendre() (in module petgem.hvfem)@\spxentry{HomLegendre()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.HomLegendre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{HomLegendre}}}{\emph{S}, \emph{Nord}}{}
Compute values of homogenized Legendre polynomials.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{S}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} affine(like) coordinates

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order

\end{itemize}

\item[{Returns}] \leavevmode
polynomial values

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{OrientE() (in module petgem.hvfem)@\spxentry{OrientE()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.OrientE}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{OrientE}}}{\emph{S}, \emph{DS}, \emph{Nori}, \emph{N}}{}
Compute the local to global transformations of edges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{S}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} projection of affine coordinates on edges

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{DS}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} projection of gradients of affine coordinates on edges

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nori}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} edge orientation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{N}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of dimensions

\end{itemize}

\item[{Returns}] \leavevmode
global transformation of edges and global transformation of gradients of edges

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{OrientTri() (in module petgem.hvfem)@\spxentry{OrientTri()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.OrientTri}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{OrientTri}}}{\emph{S}, \emph{DS}, \emph{Nori}, \emph{N}}{}
Compute the local to global transformations of edges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{S}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} projection of affine coordinates on faces

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{DS}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} projection of gradients of affine coordinates on faces

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nori}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} face orientation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{N}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of dimensions

\end{itemize}

\item[{Returns}] \leavevmode
global transformation of faces and global transformation of gradients of faces

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{PolyIJacobi() (in module petgem.hvfem)@\spxentry{PolyIJacobi()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.PolyIJacobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{PolyIJacobi}}}{\emph{X}, \emph{T}, \emph{Nord}, \emph{Minalpha}, \emph{Idec}}{}
Compute values of integrated shifted scaled Jacobi polynomials and their derivatives starting with p=1.

Result is ‘half’ of a  matrix with each row  associated to a fixed alpha.
Alpha grows by 2 in each row.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} coordinate from {[}0,1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} scaling parameter

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} max polynomial order

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Minalpha}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} first row value of alpha

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Idec}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} decision flag to compute (= FALSE polynomials with x and t derivatives, = TRUE  polynomials with x derivatives only)

\end{itemize}

\item[{Returns}] \leavevmode
polynomial values, derivatives in x (Jacobi polynomials), derivatives in t

\end{description}\end{quote}

\end{fulllineitems}

\index{PolyJacobi() (in module petgem.hvfem)@\spxentry{PolyJacobi()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.PolyJacobi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{PolyJacobi}}}{\emph{X}, \emph{T}, \emph{Nord}, \emph{Minalpha}}{}
Compute values of shifted scaled Jacobi polynomials P**alpha-i.

Result is a half of a matrix with each row associated to a fixed alpha.
Alpha grows by 2 in each row.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} coordinate from {[}0,1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} scaling parameter

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} max polynomial order

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Minalpha}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} first row value of alpha (integer)

\end{itemize}

\item[{Returns}] \leavevmode
polynomial values

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{PolyLegendre() (in module petgem.hvfem)@\spxentry{PolyLegendre()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.PolyLegendre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{PolyLegendre}}}{\emph{X}, \emph{T}, \emph{Nord}}{}
Compute values of shifted scaled Legendre polynomials.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} coordinate from {[}0,1{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} scaling parameter

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order

\end{itemize}

\item[{Returns}] \leavevmode
polynomial values

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{ProjectTetE() (in module petgem.hvfem)@\spxentry{ProjectTetE()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.ProjectTetE}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{ProjectTetE}}}{\emph{Lam}, \emph{DLam}}{}
Projection of tetrahedral edges in concordance with numbering of topological entities (vertices, edges, faces).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Lam}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} affine coordinates

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{DLam}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} gradients of affine coordinates

\end{itemize}

\item[{Returns}] \leavevmode
projection of affine coordinates on edges, projection of gradients of affine coordinates on edges

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
References:n
Fuentes, F., Keith, B., Demkowicz, L., \& Nagaraj, S. (2015). Orientation
embedded high order shape functions for the exact sequence elements of
all shapes. Computers \& Mathematics with applications, 70(4), 353-458.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ProjectTetF() (in module petgem.hvfem)@\spxentry{ProjectTetF()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.ProjectTetF}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{ProjectTetF}}}{\emph{Lam}, \emph{DLam}}{}
Projection of tetrahedral faces in concordance with numbering of topological entities (vertices, edges, faces).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Lam}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} affine coordinates

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{DLam}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} gradients of affine coordinates

\end{itemize}

\item[{Returns}] \leavevmode
projection of affine coordinates on faces, projection of gradients of affine coordinates on faces

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{compute2DGaussPoints() (in module petgem.hvfem)@\spxentry{compute2DGaussPoints()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.compute2DGaussPoints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{compute2DGaussPoints}}}{\emph{Nord}}{}
Compute 2D gauss points for high-order nédélec elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order of nedelec basis functions

\item[{Returns}] \leavevmode
coordinates of gauss points and its weights

\item[{Return type}] \leavevmode
ndarray.

\end{description}\end{quote}

\end{fulllineitems}

\index{compute3DGaussPoints() (in module petgem.hvfem)@\spxentry{compute3DGaussPoints()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.compute3DGaussPoints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{compute3DGaussPoints}}}{\emph{Nord}}{}
Compute 3D gauss points for high-order nédélec elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order of nedelec basis functions

\item[{Returns}] \leavevmode
coordinates of gauss points and its weights

\item[{Return type}] \leavevmode
ndarray.

\end{description}\end{quote}

\end{fulllineitems}

\index{computeBasisFunctions() (in module petgem.hvfem)@\spxentry{computeBasisFunctions()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.computeBasisFunctions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{computeBasisFunctions}}}{\emph{edge\_orientation}, \emph{face\_orientation}, \emph{jacobian}, \emph{invjacob}, \emph{Nord}, \emph{points}}{}
Compute the basis function for a given element.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{edges\_orientation}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} orientation for edges

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{faces\_orientation}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} orientation for faces

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{jacobian}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} jacobian matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{invjacob}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} inverse of jacobian matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order of nedelec basis functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} spatial points at which basis functions will be computed

\end{itemize}

\item[{Returns}] \leavevmode
basis functions and its curl for p-order=Nord

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeBasisFunctionsReferenceElement() (in module petgem.hvfem)@\spxentry{computeBasisFunctionsReferenceElement()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.computeBasisFunctionsReferenceElement}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{computeBasisFunctionsReferenceElement}}}{\emph{edge\_orientation}, \emph{face\_orientation}, \emph{Nord}, \emph{points}}{}
Compute the basis function for the reference element.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{edges\_orientation}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} orientation for edges

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{faces\_orientation}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} orientation for faces

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order of nedelec basis functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} spatial points at which basis functions will be computed

\end{itemize}

\item[{Returns}] \leavevmode
basis functions on reference element

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeConnectivityDOFS() (in module petgem.hvfem)@\spxentry{computeConnectivityDOFS()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.computeConnectivityDOFS}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{computeConnectivityDOFS}}}{\emph{elemsE}, \emph{elemsF}, \emph{Nord}}{}
Compute the degrees of freedom connectivity for a given list of edges, faces and elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsE}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-edge connectivity with dimensions = (number\_elements, 6)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsF}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} element/faces connectivity with dimensions = (number\_elements, 4)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order of nedelec basis functions

\end{itemize}

\item[{Returns}] \leavevmode
local/global dofs list for elements, dofs index on edges, dofs index on faces, dofs index on volumes, total number of dofs

\item[{Return type}] \leavevmode
ndarray and int

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
References:n
Amor-Martin, A., Garcia-Castillo, L. E., \& Garcia-Doñoro, D. D.
(2016). Second-order Nédélec curl-conforming prismatic element
for computational electromagnetics. IEEE Transactions on
Antennas and Propagation, 64(10), 4384-4395.
\end{sphinxadmonition}

\end{fulllineitems}

\index{computeElementOrientation() (in module petgem.hvfem)@\spxentry{computeElementOrientation()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.computeElementOrientation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{computeElementOrientation}}}{\emph{edgesEle}, \emph{nodesEle}, \emph{edgesNodesEle}, \emph{globalEdgesInFace}}{}
Compute the orientation for the computation of hierarchical basis functions of high-order (High-order nédélec basis functions).

:param ndarray edgesEle:list of element’s edges
:param ndarray nodesEle: list of element’s nodes
:param ndarray edgesNodesEle: list of nodes for each edge in edgesEle
:param ndarray globalEdgesInFace: list of edges for each face
:return: orientation for edges and orientation for faces
:rtype: ndarray.

\begin{sphinxadmonition}{note}{Note:}
References:n
Amor-Martin, A., Garcia-Castillo, L. E., \& Garcia-Doñoro, D. D.
(2016). Second-order Nédélec curl-conforming prismatic element
for computational electromagnetics. IEEE Transactions on
Antennas and Propagation, 64(10), 4384-4395.
\end{sphinxadmonition}

\end{fulllineitems}

\index{computeElementalMatrices() (in module petgem.hvfem)@\spxentry{computeElementalMatrices()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.computeElementalMatrices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{computeElementalMatrices}}}{\emph{edge\_orientation}, \emph{face\_orientation}, \emph{jacobian}, \emph{invjacob}, \emph{Nord}, \emph{sigmaEle}}{}
Compute the elemental mass matrix and stiffness matrix based ons high-order vector finite element.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{edges\_orientation}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} orientation for edges

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{faces\_orientation}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} orientation for faces

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{jacobian}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} jacobian matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{invjacob}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} inverse of jacobian matrix

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order of vector basis functions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigmaEle}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} element conductivity with dimensions (1, 2), (horizontal and vertical)

\end{itemize}

\item[{Returns}] \leavevmode
elemental mass matrix and elemental stiffness matrix

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
References:n
Fuentes, F., Keith, B., Demkowicz, L., \& Nagaraj, S. (2015). Orientation
embedded high order shape functions for the exact sequence elements of
all shapes. Computers \& Mathematics with applications, 70(4), 353-458.
\end{sphinxadmonition}

\end{fulllineitems}

\index{computeJacobian() (in module petgem.hvfem)@\spxentry{computeJacobian()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.computeJacobian}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{computeJacobian}}}{\emph{eleNodes}}{}
Compute the jacobian and its inverse.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{eleNodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} spatial coordinates of the nodes with dimensions = (4,3)

\item[{Returns}] \leavevmode
jacobian matrix and its inverse.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{computeSourceVectorRotation() (in module petgem.hvfem)@\spxentry{computeSourceVectorRotation()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.computeSourceVectorRotation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{computeSourceVectorRotation}}}{\emph{azimuth}, \emph{dip}}{}
Compute the weigths vector for source rotation in the xyz plane.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{azimuth}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} degrees for x-y plane rotation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dip}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} degrees for x-z plane rotation

\end{itemize}

\item[{Returns}] \leavevmode
weigths for source rotation

\item[{Return type}] \leavevmode
ndarray.

\end{description}\end{quote}

\end{fulllineitems}

\index{get2DJacobDet() (in module petgem.hvfem)@\spxentry{get2DJacobDet()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.get2DJacobDet}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{get2DJacobDet}}}{\emph{coordEle}, \emph{faceNumber}}{}
Compute the determinant of the jacobian for 2D integrals (when 3D basis functions are used)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coordEle}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} coordinates of the tetrahedron

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{faceNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} local face number

\end{itemize}

\item[{Returns}] \leavevmode
determinant of the 2D jacobian

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{getFaceByLocalNodes() (in module petgem.hvfem)@\spxentry{getFaceByLocalNodes()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.getFaceByLocalNodes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{getFaceByLocalNodes}}}{\emph{faceNumber}}{}
Get local nodes ordering for a given face
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{faceNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} local face number

\item[{Returns}] \leavevmode
list of local nodes for faceNumber

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{getNeumannBCface() (in module petgem.hvfem)@\spxentry{getNeumannBCface()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.getNeumannBCface}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{getNeumannBCface}}}{\emph{face\_flag}, \emph{polarization}, \emph{ud}}{}
Get Neumann boundary condition for boundary face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{face\_flag}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} face flag (side on which face belongs)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{polarization}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polarization mode (x-mode or y-mode)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ud}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} magnetic field vector

\end{itemize}

\item[{Returns}] \leavevmode
value of Neumann boundary condition for boundary face

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{getNormalVector() (in module petgem.hvfem)@\spxentry{getNormalVector()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.getNormalVector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{getNormalVector}}}{\emph{faceNumber}, \emph{invJacobMatrix}}{}
This function computes the normal vector for a given tetrahedral face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{faceNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} local face number

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{invJacobMatrix}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} inverse of jacobian matrix

\end{itemize}

\item[{Returns}] \leavevmode
face normal vector

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{getRealFromReference() (in module petgem.hvfem)@\spxentry{getRealFromReference()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.getRealFromReference}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{getRealFromReference}}}{\emph{rRef}, \emph{verticesReal}}{}
Translate a point defined in the reference element (rRef) to the real element (rReal)
defined by verticesReal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rRef}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} reference coordinates

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{verticesReal}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} real coordinates of element (4x3) = (4 nodes x 3 coordinates)

\end{itemize}

\item[{Returns}] \leavevmode
points in real element

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{shape3DETet() (in module petgem.hvfem)@\spxentry{shape3DETet()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.shape3DETet}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{shape3DETet}}}{\emph{X}, \emph{Nord}, \emph{NoriE}, \emph{NoriF}}{}
Compute values of 3D tetrahedron element H(curl) shape functions and their derivatives.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{X}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} master tetrahedron coordinates from (0,1)\textasciicircum{}3

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nord}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} polynomial order

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{NoriE}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} edge orientation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{NoriF}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} face orientation

\end{itemize}

\item[{Returns}] \leavevmode
number of dof, values of the shape functions at the point, curl of the shape functions

\item[{Return type}] \leavevmode
ndarray.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
References:n
Fuentes, F., Keith, B., Demkowicz, L., \& Nagaraj, S. (2015). Orientation
embedded high order shape functions for the exact sequence elements of
all shapes. Computers \& Mathematics with applications, 70(4), 353-458.
\end{sphinxadmonition}

\end{fulllineitems}

\index{tetrahedronXYZToXiEtaZeta() (in module petgem.hvfem)@\spxentry{tetrahedronXYZToXiEtaZeta()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.tetrahedronXYZToXiEtaZeta}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{tetrahedronXYZToXiEtaZeta}}}{\emph{eleNodes}, \emph{points}}{}
Compute the reference tetrahedron coordinates from xyz global tetrahedron coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eleNodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} spatial coordinates of the nodes with dimensions = (4,3)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} xyz points coordinates to be transformed

\end{itemize}

\item[{Returns}] \leavevmode
xietazeta points coordinates

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{transform2Dto3DInReferenceElement() (in module petgem.hvfem)@\spxentry{transform2Dto3DInReferenceElement()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.transform2Dto3DInReferenceElement}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{transform2Dto3DInReferenceElement}}}{\emph{points2D}, \emph{faceNumber}}{}
Transforms 2D points defined on some face into its 3D representation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points2D}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} 2D points to be transformed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{faceNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} local face number

\end{itemize}

\item[{Returns}] \leavevmode
resulting 3D points

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{unitary\_test() (in module petgem.hvfem)@\spxentry{unitary\_test()}\spxextra{in module petgem.hvfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/hvfem:petgem.hvfem.unitary_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.hvfem.}}\sphinxbfcode{\sphinxupquote{unitary\_test}}}{}{}
Unitary test for hvfem.py script.

\end{fulllineitems}



\subsubsection{vectors.py}
\label{\detokenize{petgem/vectors:module-petgem.vectors}}\label{\detokenize{petgem/vectors:vectors-py}}\label{\detokenize{petgem/vectors::doc}}\index{petgem.vectors (module)@\spxentry{petgem.vectors}\spxextra{module}}
Define standard vector and matrix functions.
\index{deleteDuplicateRows() (in module petgem.vectors)@\spxentry{deleteDuplicateRows()}\spxextra{in module petgem.vectors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/vectors:petgem.vectors.deleteDuplicateRows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.vectors.}}\sphinxbfcode{\sphinxupquote{deleteDuplicateRows}}}{\emph{matrix}}{}
Delete duplicate rows in a matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{matrix}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} input matrix to be processed.

\item[{Returns}] \leavevmode
matrix without duplicate rows

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{findUniqueRows() (in module petgem.vectors)@\spxentry{findUniqueRows()}\spxextra{in module petgem.vectors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/vectors:petgem.vectors.findUniqueRows}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.vectors.}}\sphinxbfcode{\sphinxupquote{findUniqueRows}}}{\emph{array}, \emph{return\_index=False}, \emph{return\_inverse=False}}{}
Find unique rows of a two-dimensional numpy array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ndarray}} \textendash{} array to be processed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_index}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} the indices of array that result in the
unique array.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_inverse}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} indices of the unique array that
can be used to reconstruct array.

\end{itemize}

\item[{Returns}] \leavevmode
unique rows.

\item[{Return type}] \leavevmode
ndarray.

\end{description}\end{quote}

\end{fulllineitems}

\index{invConnectivity() (in module petgem.vectors)@\spxentry{invConnectivity()}\spxextra{in module petgem.vectors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/vectors:petgem.vectors.invConnectivity}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.vectors.}}\sphinxbfcode{\sphinxupquote{invConnectivity}}}{\emph{M}, \emph{nP}}{}
Compute the opposite connectivity matrix of M.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{M}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} connectivity matrix with dimensions = (nElems,eleOrder)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nP}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of nodes/edges/faces in matrix M.

\end{itemize}

\item[{Returns}] \leavevmode
connectivity matrix with dimensions = (nNodes,S), (nEdges,S) or (nFaces,S)

\item[{Return type}] \leavevmode
ndarray.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
eleOrder determines the number of entities per element in matrix M,
therefore 4 is the nodal element order, 6 is the edge element order and
3 is the element order of faces.
S in the output is the maximum number of elements sharing a given node/edge/face

If M represents a element/nodes connectivity, the function computes
a node/elements connectivity.

If M represents a element/edges connectivity, the function computes
a edge/elements connectivity.

If M represents a element/faces connectivity, the function computes
a faces/elements connectivity.
\end{sphinxadmonition}

\end{fulllineitems}

\index{is\_duplicate\_entry() (in module petgem.vectors)@\spxentry{is\_duplicate\_entry()}\spxextra{in module petgem.vectors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/vectors:petgem.vectors.is_duplicate_entry}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.vectors.}}\sphinxbfcode{\sphinxupquote{is\_duplicate\_entry}}}{\emph{x}}{}
Compute number of duplicate entries in a vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{int-array}}) \textendash{} matrix.

\item[{Returns}] \leavevmode
number of duplicate entries.

\item[{Return type}] \leavevmode
int.

\end{description}\end{quote}

\end{fulllineitems}

\index{unitary\_test() (in module petgem.vectors)@\spxentry{unitary\_test()}\spxextra{in module petgem.vectors}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/vectors:petgem.vectors.unitary_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.vectors.}}\sphinxbfcode{\sphinxupquote{unitary\_test}}}{}{}
Unitary test for vectors.py script.

\end{fulllineitems}



\subsection{Solver}
\label{\detokenize{Manual:solver}}

\subsubsection{solver.py}
\label{\detokenize{petgem/solver:module-petgem.solver}}\label{\detokenize{petgem/solver:solver-py}}\label{\detokenize{petgem/solver::doc}}\index{petgem.solver (module)@\spxentry{petgem.solver}\spxextra{module}}
Define functions a 3D CSEM/MT solver using high-order vector finite element method (HEFEM).
\index{unitary\_test() (in module petgem.solver)@\spxentry{unitary\_test()}\spxextra{in module petgem.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/solver:petgem.solver.unitary_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.solver.}}\sphinxbfcode{\sphinxupquote{unitary\_test}}}{}{}
Unitary test for solver.py script.

\end{fulllineitems}



\subsection{Parallel}
\label{\detokenize{Manual:parallel}}

\subsubsection{parallel.py}
\label{\detokenize{petgem/parallel:module-petgem.parallel}}\label{\detokenize{petgem/parallel:parallel-py}}\label{\detokenize{petgem/parallel::doc}}\index{petgem.parallel (module)@\spxentry{petgem.parallel}\spxextra{module}}
Define classes and functions for parallel computations within \sphinxstylestrong{PETGEM}.
\index{createParallelDenseMatrix() (in module petgem.parallel)@\spxentry{createParallelDenseMatrix()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.createParallelDenseMatrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{createParallelDenseMatrix}}}{\emph{dimension1}, \emph{dimension2}, \emph{communicator=None}}{}
Create a parallel dense matrix in petsc format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dimension1}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} matrix dimension (rows).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dimension2}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} matrix dimension (columns).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
parallel matrix.

\item[{Return type}] \leavevmode
petsc parallel and dense matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{createParallelMatrix() (in module petgem.parallel)@\spxentry{createParallelMatrix()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.createParallelMatrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{createParallelMatrix}}}{\emph{dimension1}, \emph{dimension2}, \emph{nnz}, \emph{matrix\_type}, \emph{communicator=None}}{}
Create a parallel sparse matrix in petsc format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dimension1}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} matrix dimension (rows).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dimension2}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} matrix dimension (columns).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nnz}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} not zero pattern for allocation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{matrix\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} matrix type for parallel computations.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
parallel matrix.

\item[{Return type}] \leavevmode
petsc AIJ parallel matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{createParallelVector() (in module petgem.parallel)@\spxentry{createParallelVector()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.createParallelVector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{createParallelVector}}}{\emph{size}, \emph{vector\_type}, \emph{communicator=None}}{}
Create a parallel vector in petsc format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} vector size.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vector\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} vector type for parallel computations.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
parallel vector.

\item[{Return type}] \leavevmode
petsc parallel vector.

\end{description}\end{quote}

\end{fulllineitems}

\index{createSequentialDenseMatrixWithArray() (in module petgem.parallel)@\spxentry{createSequentialDenseMatrixWithArray()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.createSequentialDenseMatrixWithArray}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{createSequentialDenseMatrixWithArray}}}{\emph{dimension1}, \emph{dimension2}, \emph{data}}{}
Given an input array, create a sequential dense matrix in petsc format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dimension1}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} matrix dimension (rows).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dimension2}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} matrix dimension (columns).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} data to be exported.

\end{itemize}

\item[{Returns}] \leavevmode
parallel matrix.

\item[{Return type}] \leavevmode
petsc parallel and dense matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{createSequentialVector() (in module petgem.parallel)@\spxentry{createSequentialVector()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.createSequentialVector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{createSequentialVector}}}{\emph{size}, \emph{vector\_type}, \emph{communicator=None}}{}
Create a sequential vector in petsc format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} vector size.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vector\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} vector type for parallel computations.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
sequential vector.

\item[{Return type}] \leavevmode
petsc sequential vector.

\end{description}\end{quote}

\end{fulllineitems}

\index{createSequentialVectorWithArray() (in module petgem.parallel)@\spxentry{createSequentialVectorWithArray()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.createSequentialVectorWithArray}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{createSequentialVectorWithArray}}}{\emph{data}}{}
Given an input array, create a sequential vector in petsc format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} data to be exported.

\item[{Returns}] \leavevmode
parallel matrix.

\item[{Return type}] \leavevmode
petsc parallel and dense matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{readPetscMatrix() (in module petgem.parallel)@\spxentry{readPetscMatrix()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.readPetscMatrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{readPetscMatrix}}}{\emph{input\_file}, \emph{communicator=None}}{}
Read a Petsc matrix which format is defined by two files: input\_file.dat and input\_file.info.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{input\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file name to be readed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
petsc\_matrix.

\item[{Return type}] \leavevmode
petsc sparse matrix.

\end{description}\end{quote}

\end{fulllineitems}

\index{readPetscVector() (in module petgem.parallel)@\spxentry{readPetscVector()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.readPetscVector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{readPetscVector}}}{\emph{input\_file}, \emph{communicator=None}}{}
Read a Petsc vector which format is defined by two files: input\_file.dat and input\_file.info.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{input\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file name to be readed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
petsc\_vector.

\item[{Return type}] \leavevmode
petsc vector.

\end{description}\end{quote}

\end{fulllineitems}

\index{unitary\_test() (in module petgem.parallel)@\spxentry{unitary\_test()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.unitary_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{unitary\_test}}}{}{}
Unitary test for parallel.py script.

\end{fulllineitems}

\index{writeDenseMatrix() (in module petgem.parallel)@\spxentry{writeDenseMatrix()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.writeDenseMatrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{writeDenseMatrix}}}{\emph{output\_file}, \emph{data}, \emph{communicator=None}}{}
Write a Petsc dense matrix which format is defined by two files: output\_file.dat and output\_file.info.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file name to be saved.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{matrix data}} (\sphinxstyleliteralemphasis{\sphinxupquote{petsc}}) \textendash{} dense matrix to be saved.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{writeParallelDenseMatrix() (in module petgem.parallel)@\spxentry{writeParallelDenseMatrix()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.writeParallelDenseMatrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{writeParallelDenseMatrix}}}{\emph{output\_file}, \emph{data}, \emph{communicator=None}}{}
Write a Petsc parallel dense matrix which format is defined by two files: output\_file.dat and output\_file.info.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file name to be saved.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{matrix data}} (\sphinxstyleliteralemphasis{\sphinxupquote{petsc}}) \textendash{} dense matrix to be saved.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{writePetscVector() (in module petgem.parallel)@\spxentry{writePetscVector()}\spxextra{in module petgem.parallel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/parallel:petgem.parallel.writePetscVector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.parallel.}}\sphinxbfcode{\sphinxupquote{writePetscVector}}}{\emph{output\_file}, \emph{data}, \emph{communicator=None}}{}
Write a Petsc vector which format is defined by two files: output\_file.dat and output\_file.info.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file name to be saved.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vector data}} (\sphinxstyleliteralemphasis{\sphinxupquote{petsc}}) \textendash{} array to be saved.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{communicator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} mpi communicator.

\end{itemize}

\item[{Returns}] \leavevmode
None.

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Post-processing}
\label{\detokenize{Manual:post-processing}}

\subsubsection{preprocessing.py}
\label{\detokenize{petgem/postprocessing:module-petgem.postprocessing}}\label{\detokenize{petgem/postprocessing:preprocessing-py}}\label{\detokenize{petgem/postprocessing::doc}}\index{petgem.postprocessing (module)@\spxentry{petgem.postprocessing}\spxextra{module}}
Define data postprocessing operations for \sphinxstylestrong{PETGEM}.
\index{computeImpedance() (in module petgem.postprocessing)@\spxentry{computeImpedance()}\spxextra{in module petgem.postprocessing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/postprocessing:petgem.postprocessing.computeImpedance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.postprocessing.}}\sphinxbfcode{\sphinxupquote{computeImpedance}}}{\emph{fields}, \emph{omega}, \emph{mu}}{}
Compute apparent resistiviy, phase, tipper and impedance for MT mode.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fields}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of numpy arrays with electromagnetic fields with dimensions = (number\_polarizations, number\_receivers, number\_EM\_components)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omega}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} angular frequency

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mu}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} medium permeability.

\end{itemize}

\item[{Returns}] \leavevmode
apparent resistivity, phase, tipper and impedance.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{fieldInterpolator() (in module petgem.postprocessing)@\spxentry{fieldInterpolator()}\spxextra{in module petgem.postprocessing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/postprocessing:petgem.postprocessing.fieldInterpolator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.postprocessing.}}\sphinxbfcode{\sphinxupquote{fieldInterpolator}}}{\emph{solution\_vector}, \emph{nodes}, \emph{elemsN}, \emph{elemsE}, \emph{edgesN}, \emph{elemsF}, \emph{facesE}, \emph{dof\_connectivity}, \emph{points}, \emph{inputSetup}}{}
Interpolate electromagnetic field for a set of 3D points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{solution\_vector}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray-petsc}}) \textendash{} vector field to be interpolated

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} nodal coordinates

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsN}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-node connectivity with dimensions = (number\_elements, 4)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsE}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} elements-edge connectivity with dimensions = (number\_elements, 6)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{edgesN}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} edge-node connectivity with dimensions = (number\_edges, 2)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elemsF}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} element-faces connectivity with dimensions = (number\_elements, 4)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{facesE}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} face-edges connectivity with dimensions = (number\_faces, 3)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dof\_connectivity}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} local/global dofs list for elements, dofs index on edges, dofs index on faces, dofs index on volumes, total number of dofs

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{ndarray}}) \textendash{} point coordinates

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inputSetup}} (\sphinxstyleliteralemphasis{\sphinxupquote{obj}}) \textendash{} inputSetup object.

\end{itemize}

\item[{Returns}] \leavevmode
electromagnetic fields for a set of 3D points

\item[{Return type}] \leavevmode
ndarray and int

\end{description}\end{quote}

\end{fulllineitems}

\index{unitary\_test() (in module petgem.postprocessing)@\spxentry{unitary\_test()}\spxextra{in module petgem.postprocessing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{petgem/postprocessing:petgem.postprocessing.unitary_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{petgem.postprocessing.}}\sphinxbfcode{\sphinxupquote{unitary\_test}}}{}{}
Unitary test for postprocessing.py script.

\end{fulllineitems}



\chapter{Publications}
\label{\detokenize{Publications:publications}}\label{\detokenize{Publications:id1}}\label{\detokenize{Publications::doc}}
Papers:
\begin{itemize}
\item {} 
Castillo-Reyes, O., Queralt, P., Marcuello, A., Ledo, J. (2021). \sphinxhref{https://doi.org/10.1109/TGRS.2021.3069042}{Land CSEM Simulations and Experimental Test Using Metallic Casing in a Geothermal Exploration Context: Vall{}`es Basin (NE Spain) Case Study}. IEEE Transactions on Geoscience and Remote Sensing.

\item {} 
Castillo-Reyes, O., de la Puente, J., García-Castillo, L. E., Cela, J.M. (2019). \sphinxhref{https://doi.org/10.1093/gji/ggz285}{Parallel 3-D marine controlled-source electromagnetic modelling using high-order tetrahedral Nédélec elements}. Geophysical Journal International, Volume 219, Issue 1, October 2019, Pages 39\textendash{}65.

\item {} 
Castillo-Reyes, O., de la Puente, Cela, J. M. \sphinxhref{https://doi.org/10.1016/j.cageo.2018.07.005}{PETGEM: A parallel code for 3D CSEM forward modeling using edge finite elements}. Computers \& Geosciences, vol 119: 123-136. ISSN 0098-3004. Elsevier.

\item {} 
Castillo-Reyes, O., de la Puente, Cela, J. M. \sphinxhref{https://link.springer.com/chapter/10.1007/978-3-319-57972-6\_18}{Three-Dimensional CSEM modelling on unstructured tetrahedral meshes using edge finite elements}. In: Barrios Hernández C., Gitler I., Klapp J. (eds) High Performance Computing. CARLA 2016. Communications in Computer and Information Science, vol 697: 247-256. ISBN 978-3-319-57971-9 Springer, Cham. 2017.

\item {} 
Castillo-Reyes, O., de la Puente, Cela, J. M. \sphinxhref{https://doi.org/10.1109/UEMCON.2016.7777804}{Improving edge finite element assembly for geophysical electromagnetic modelling on shared-memory architectures}. 7th Annual Ubiquitous Computing, Electronics \& Mobile Communication Conference \textendash{} UEMCON. 2016.

\item {} 
Castillo-Reyes, O., de la Puente, J., Puzyrev, V., and Cela, J. M., \sphinxhref{http://www.bsc.es/publications/edge-based-parallel-framework-simulation-3d-csem-surveys}{Edge-based parallel framework for the simulation of 3D CSEM surveys}. ICE Barcelona-AAPG/SEG International Conference \& Exhibition. 2016.

\item {} 
Castillo-Reyes, O., de la Puente, J., Barucq, H., Diaz, J., and Cela, J. M., \sphinxhref{http://www.bsc.es/publications/parallel-and-vectorized-code-csem-surveys-geophysics-edge-based-approach}{Parallel and vectorized code for CSEM surveys in geophysics: An edge-based approach}. ECCOMAS. 2016.

\item {} 
Castillo-Reyes, O., de la Puente, J., Modesto, D., Puzyrev, V., and Cela, J. M., \sphinxhref{http://www.bsc.es/publications/parallel-tool-numerical-approximation-3d-electromagnetic-surveys-geophysics}{A parallel tool for numerical approximation of 3D electromagnetic surveys in geophysics}. Computación y Sistemas: Topic trends in computing research, vol. 20, no. 1, pp 29-39. 2016.

\item {} 
Castillo-Reyes, O., de la Puente, J., Puzyrev, V., and Cela, J. M., \sphinxhref{http://www.bsc.es/publications/towards-hpc-tool-simulation-3d-csem-surveys-edge-based-approach}{Towards an HPC tool for simulation of 3D CSEM surveys: an edge-based approach}. PRACEdays16 Conference. 2016.

\item {} 
Castillo-Reyes, O., de la Puente, J., Puzyrev, V., and Cela, J. M., \sphinxhref{http://www.bsc.es/publications/assessment-edge-based-finite-element-technique-geophysical-electromagnetic-problems}{Assessment of edge-based finite element technique for geophysical electromagnetic problems: efficiency, accuracy and reliability}. Proceedings of the 1st Pan-American Congress on Computational Mechanics and XI Argentine Congress on Computational Mechanics. CIMNE, pp. 984-995, 2015.

\item {} 
Castillo-Reyes, O., de la Puente, J., Puzyrev, V., and Cela, J. M., \sphinxhref{http://dx.doi.org/10.1109/IEMCON.2015.7344499}{Edge-based electric field formulation in 3D CSEM simulations: a parallel approach}. Proceedings of the 6th International Conference and Workshop on Computing and Communication. IEEE, 2015.

\item {} 
Castillo-Reyes, O., de la Puente, J., Puzyrev, V., and Cela, J. M., \sphinxhref{http://www.bsc.es/publications/edge-elements-geophysical-electromagnetic-problems-new-implementation-challenge}{Edge-elements for geophysical electromagnetic problems: a new implementation challenge}. PRACEdays15 Conference. 2015.

\item {} 
Castillo-Reyes, O., de la Puente, J., Puzyrev, V., and Cela, J. M., \sphinxhref{http://www.bsc.es/publications/hpc-and-edge-elements-geophysical-electromagnetic-problems-overview}{HPC and edge elements for geophysical electromagnetic problems: an overview}. BSC Doctoral Symposium (2nd: 2015: Barcelona). 2015.

\item {} 
Castillo-Reyes, O., de la Puente, J., Puzyrev, V., and Cela, J. M., \sphinxhref{http://dx.doi.org/10.1109/ICCSAT.2015.7362921}{Parallel and numerical issues of the edge finite element method for 3D controlled-source electromagnetic surveys}. Proceedings of the International Conference on Computing Systems and Telematics. IEEE, 2015.

\end{itemize}

Conferences:
\begin{itemize}
\item {} 
Castillo-Reyes, O. Modeling and Inversion 3D Electromagnetic Datasets on HPC platforms. ADMOS 2021 10th International Conference On Adaptive Modeling and Simulation. June 2021.

\item {} 
Castillo-Reyes, O. Reservoir characterization using geophysics electromagnetic and HPC. SIAM Conference on Mathematical \& Computational Issues in the Geosciences. June 2021.

\item {} 
Castillo-Reyes, O., Queralt, P., Marcuello, A., Ledo, J., Amor-Martin, A., García-Castillo, L.E. 14:00 - 15:00 3D Electromagnetic Modeling and Inversion using an Open-Source Paradigm: Experiences and Perspectives. SIAM Conference on Mathematical \& Computational Issues in the Geosciences. June 2021.

\item {} 
Castillo-Reyes, O. Electromagnetic modeling using steel casing in a geothermal exploration context Online AGU Fall Meeting. 8o Congreso Metropolitano de Modelado y Simulación Numérica 2021. May 2021.

\item {} 
Co-author.  Open-source lanscape for Three-Dimensional Controlled-Source Electromagnetic Modeling. Online AGU Fall Meeting. December 2020.

\item {} 
Castillo-Reyes, O. Control Source Electromagnetic test in the Vallès Basin (Spain) for geothermal characterization: experiment setup and numerical simulations. Online AGU Fall Meeting. December 2020.

\item {} 
Castillo-Reyes, O. Land CSEM simulations and experimental test using metallic casing in a geothermal exploration context: Vallés Basin (NE Spain) case study. Online MATHROCKS Workshop on Simulation and Inversion Methods in Geophysics. Workshop virtual organized by the Institut National de Recherche en Informatique et en Automatique \textendash{} INRIA (Pau University, France) and University of the Basque Country (Spain). November 2020.

\item {} 
Castillo-Reyes, O. Electromagnetic modeling for geothermal resources exploration. PIXIL Virtual Workshop. Virtual conference organized by the Institut National de Recherche en Informatique et en Automatique \textendash{} INRIA. Pau University, France. May 2020.

\item {} 
Castillo-Reyes, O. HPC with python for numerical modeling in geophysics. Workshop on mathematical and computational modelling on the Earth. LaCaN, Polytechnic University of Catalonia, Barcelona, Spain. May 2019.

\item {} 
Castillo-Reyes, O. HPC for numerical simulation in geophysics. 7° Congreso metropolitano de modelado y simulación numérica. National Autonomous University of Mexico \textendash{} UNAM. CDMX, Mexico. May 2019.

\item {} 
Castillo-Reyes, O. Electromagnetic modeling using Nédélec elements of high-order and HPC. XXXIX Ibero-Latin American Congress on Computational Methods in Engineering \textendash{} CILAMCE. Sorbonne Universités. Paris / Compiègne, France. November 2018.

\item {} 
Castillo-Reyes, O. HPC code development using Python. Mexican Supercomputing Network annual meeting \textendash{} RedMexSu. University of Guadalajara. Guadajalara, Mexico. October 2018.

\item {} 
Castillo-Reyes, O. HPC geophysical electromagnetic modeling. Fifth International Congress on Multiphysics, Multiscale, and Optimization problems. University of the Basque Country. Bilbao, Spain. May 2018.

\item {} 
Castillo-Reyes, O. Python performance for HPC geophysical applications. 9th International Supercomputing Conference in Mexico \textendash{} ISUM 2018. Red Mexicana de Supercómputo. Mérida, Yucatán, Mexico. March 2018.

\item {} 
Castillo-Reyes, O. Overview of numerical techniques and applications for CSEM/MT geophysical surveys. SIAM Conference on Mathematical and Computational Issues in the Geosciences. University Erlangen-Nürnberg. Erlangen, Germany. September 2017.

\item {} 
Castillo-Reyes, O. PETGEM: Parallel Edge-based Tool for Geophysical Electromagnetic Modelling. Congress on Numerical Methods in Engineering. Technical University of Valencia. Valencia, Spain. July 2017.

\item {} 
Castillo-Reyes, O. PETGEM: potential of 3D CSEM modelling using a new HPC tool for exploration geophysics. 10th International Marine Electromagnetics conference \textendash{} MARELEC. University of Liverpool. Liverpool, United Kingdom. June 2017.

\item {} 
Castillo-Reyes, O. High performance computing using python: advances in geophysical electromagnetic modelling. Computing and Electromagnetics International Workshop. Polytechnic University of Catalonia. Barcelona, Spain. June 2017.

\item {} 
Castillo-Reyes, O. Python code for CSEM modelling in geophysics and HPC architectures: advances and challenges. 2do Foro Internacional de Talento Mexicano \textendash{} Innovation Match MX 2016-2017. Mexico, D.F. May 2017.

\item {} 
Castillo-Reyes, O. Python for HPC geophysical applications. GeoPython 2017. University of Applied Sciences and Arts Northwestern Switzerland. Basel, Switzerland. May 2017.

\item {} 
Castillo-Reyes, O. Python for HPC geophysical electromagnetic applications: experiences and perspectives. 4th BSC International Doctoral Symposium. Barcelona, Spain. May 2017.

\item {} 
Castillo-Reyes, O. See underneath. High Performance Computing, geophysics and electromagnetic methods. Interdisciplinary Meeting of Predoctoral Researchers \textendash{} JIPI 2017. University of Barcelona. Barcelona, Spain. February 2017.

\item {} 
Castillo-Reyes, O. Supercomputing and electromagnetic modelling in geophysics: advances and challenges. Centro de Ciencias de la tierra. University of Veracruz. Xalapa, Veracruz, Mexico. December 2016.

\item {} 
Castillo-Reyes, O. Improving edge finite element assembly for geophysical electromagnetic modelling on shared-memory architectures. 7th IEEE Annual Ubiquitous Computing, Electronics \& Mobile Communication Conference \textendash{} UEMCON 2016. New York, USA. October 2016.

\item {} 
Castillo-Reyes, O. Three-dimensional CSEM modelling on unstructured tetrahedral meshes using edge finite elements. Latin American High Performance Computing Conference \textendash{} CARLA 2016.  Mexico, D.F. August 2016.

\item {} 
Castillo-Reyes, O. Edge-based parallel code for CSEM surveys in geophysics: performance and accuracy improvements. 12th World Congress on Computational Mechanics \textendash{} WCCM XII. Seúl, Corea. July 2016.

\item {} 
Castillo-Reyes, O. Towards an HPC tool for 3D CSEM forward modelling in geophysics. Fourth International Congress on Multiphysics, Multiscale, and Optimization problems. Bilbao, España. May 2016

\item {} 
Castillo-Reyes, O. High performance computing, geophysics and numerical methods: a symbiotic relation. 1er Foro Internacional de Talento Mexicano \textendash{} Innovation Match MX 2015-2016. Guadalajara, Jalisco, México. April 2016.

\item {} 
Castillo-Reyes, O. Edge-based electric field formulation in 3D CSEM simulations: a parallel approach. 6th International Conference and Workshop on Computing and Communication \textendash{} IEMCON \textendash{} 2015. University of British Columbia. Vancouver, Canada. October 2015.

\item {} 
Castillo-Reyes, O. High Performance Computing and electromagnetic modeling in geophysics: from concepts to application. Research Center in Computing. National Polytechnic Institute. Mexico, D.F. October 2015.

\item {} 
Castillo-Reyes, O. Parallel and numerical issues of the edge finite element method for 3D controlled-source electromagnetic surveys. IEEE International Conference on Computing Systems and Telematics. University of Veracruz. Xalapa, Veracruz, Mexico. October 2015.

\item {} 
Castillo-Reyes, O. “Your Thesis in 3 Minutes” (3TM) with the topic: Edge-elements formulation of CSEM in geophysics: a parallel approach. Jornadas de Cooperación CONACyT \textendash{} Cataluña 2015. Polytechnic University of Catalonia \textendash{} National Council of Science and Technology of Mexico. Barcelona, Spain. June 2015.

\item {} 
Castillo-Reyes, O. Edge-elements for geophysical electromagnetic problems: A new implementation challenge. PRACE Scientific and Industrial Conference 2015 \textendash{} PRACEDays15. Dublin, Ireland. April 2015.

\item {} 
Castillo-Reyes, O. HPC and edge elements for geophysical electromagnetic problems: an overview. 2nd BSC International Doctoral Symposium. Barcelona, Spain. April 2015.

\item {} 
Castillo-Reyes, O. Assessment of edge-based finite element technique for geophysical electromagnetic problems: efficiency, accuracy and reliability. 1st. Pan-American Congress on Computational Mechanics \textendash{} PANACM 2015. IACM. Buenos Aires, Argentina. April 2015.

\item {} 
Castillo-Reyes, O. HPC solutions for oil industry: trends and challenges. Centro de Ciencias de la Tierra. University of Veracruz. Xalapa, Veracruz, Mexico. December 2014.

\item {} 
Castillo-Reyes, O. High Performance Computing, Science and Engineering. Master in Telematic. School of Accounting and Management. University of Veracruz. Xalapa, Veracruz, Mexico. December 2014.

\item {} 
Castillo-Reyes, O. HPC solutions for oil industry: trends and challenges. IV Simposio de Becarios CONACyT en Europa. Strasbourg, France. November 2014.

\end{itemize}


\chapter{Support}
\label{\detokenize{Publications:support}}
Work on PETGEM has received funding from the European Union’s Horizon 2020 research and innovation programme under
the Marie Sklodowska-Curie grant agreement No. 644202. The research leading to these results has received funding
from the European Union’s Horizon 2020 Programme (2014-2020) and from Brazilian Ministry of Science, Technology and
Innovation through Rede Nacional de Pesquisa (RNP) under the \sphinxhref{http://www.hpc4e.eu}{HPC4E Project} , grant agreement
No. 689772. Further, this project has received funding from the European Union’s Horizon 2020 research and innovation
programme under the Marie Sklodowska-Curie grant agreement No. 777778. Moreover, the development of PETGEM has received
funding from the European Union’s Horizon 2020 programme, grant agreement N◦828947, and from the Mexican Department of
Energy, CONACYT-SENER Hidrocarburos grant agreement N◦B-S-69926. Finally, this project has been 65\% cofinanced by the
European Regional Development Fund (ERDF) through the Interreg V-A Spain-France-Andorra program
(POCTEFA2014-2020). POCTEFA aims to reinforce the economic and social integration of the French-Spanish-Andorran
border. Its support is focused on developing economic, social and environmental cross-border activities through joint
strategies favouring sustainable territorial development


\chapter{Download}
\label{\detokenize{Download:download}}\label{\detokenize{Download:id1}}\label{\detokenize{Download::doc}}

\section{Conditions of use}
\label{\detokenize{Download:conditions-of-use}}\label{\detokenize{Download:id2}}
PETGEM is developed as open-source under
\sphinxcode{\sphinxupquote{BSD-3}} license.


\section{Downloads}
\label{\detokenize{Download:downloads}}\label{\detokenize{Download:download-petgem}}

\subsection{Scripts}
\label{\detokenize{Download:scripts}}\begin{itemize}
\item {} 
PETGEM is available for download at the project website generously hosted by PyPi and GitHub. Download \sphinxhref{https://pypi.python.org/pypi/petgem/}{here} or \sphinxhref{https://github.com/ocastilloreyes/petgem}{here}.

\item {} 
\sphinxcode{\sphinxupquote{kernel.py}}: python script that manages the PETGEM work-flow. Download \sphinxcode{\sphinxupquote{here}}.

\item {} 
\sphinxcode{\sphinxupquote{petsc.opts}}: options file for \sphinxhref{http://www.mcs.anl.gov/petsc/}{PETSc} solvers/preconditioners. Download \sphinxcode{\sphinxupquote{here}}.

\item {} 
\sphinxcode{\sphinxupquote{params.yaml}}: file that defines physical parameters of the 3D CSEM survey. Download \sphinxcode{\sphinxupquote{here}}.

\end{itemize}


\subsection{CSEM examples}
\label{\detokenize{Download:csem-examples}}\begin{itemize}
\item {} 
Example 1: Dataset for the Canonical model of an off-shore hydrocarbon reservoir (Nédélec elements of first-order). Download \sphinxcode{\sphinxupquote{here}}.

\item {} 
Example 2: Dataset for the Canonical model of an off-shore hydrocarbon reservoir (Nédélec elements of second-order). Download \sphinxcode{\sphinxupquote{here}}.

\item {} 
Example 3: Dataset for the use of PETSc solvers. Download \sphinxcode{\sphinxupquote{here}}.

\end{itemize}


\subsection{MT examples}
\label{\detokenize{Download:mt-examples}}\begin{itemize}
\item {} 
Example 1: Dataset for the 3D trapezoidal hill model (Nédélec elements of second-order). Download \sphinxcode{\sphinxupquote{here}}.

\end{itemize}


\chapter{Contact}
\label{\detokenize{Contact:contact}}\label{\detokenize{Contact:id1}}\label{\detokenize{Contact::doc}}
\begin{DUlineblock}{0em}
\item[] Octavio Castillo-Reyes
\item[] Tel: +34 934137992
\item[] email: \sphinxhref{mailto:octavio.castillo@bsc.es}{octavio.castillo@bsc.es}
\item[] Location: Nexus II building - third floor C/ Jordi Girona, 29. Barcelona 08034
\end{DUlineblock}


\chapter{View map}
\label{\detokenize{Contact:view-map}}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{k}
\item\relax\sphinxstyleindexentry{kernel}\sphinxstyleindexpageref{petgem/kernel:\detokenize{module-kernel}}
\indexspace
\bigletter{p}
\item\relax\sphinxstyleindexentry{petgem.common}\sphinxstyleindexpageref{petgem/common:\detokenize{module-petgem.common}}
\item\relax\sphinxstyleindexentry{petgem.hvfem}\sphinxstyleindexpageref{petgem/hvfem:\detokenize{module-petgem.hvfem}}
\item\relax\sphinxstyleindexentry{petgem.mesh}\sphinxstyleindexpageref{petgem/mesh:\detokenize{module-petgem.mesh}}
\item\relax\sphinxstyleindexentry{petgem.parallel}\sphinxstyleindexpageref{petgem/parallel:\detokenize{module-petgem.parallel}}
\item\relax\sphinxstyleindexentry{petgem.postprocessing}\sphinxstyleindexpageref{petgem/postprocessing:\detokenize{module-petgem.postprocessing}}
\item\relax\sphinxstyleindexentry{petgem.preprocessing}\sphinxstyleindexpageref{petgem/preprocessing:\detokenize{module-petgem.preprocessing}}
\item\relax\sphinxstyleindexentry{petgem.solver}\sphinxstyleindexpageref{petgem/solver:\detokenize{module-petgem.solver}}
\item\relax\sphinxstyleindexentry{petgem.vectors}\sphinxstyleindexpageref{petgem/vectors:\detokenize{module-petgem.vectors}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}